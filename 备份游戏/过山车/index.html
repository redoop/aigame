<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿‡å±±è½¦ - é©¬å½¢ & é¾™å½¢</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: Arial, sans-serif; background: #000; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 16px; z-index: 10;
        }
        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 12px; z-index: 10;
        }
        button {
            padding: 10px 20px; font-size: 15px;
            background: rgba(255,255,255,0.9); border: 2px solid #333;
            border-radius: 8px; cursor: pointer; transition: all 0.2s;
        }
        button:hover { background: white; transform: scale(1.05); }
        button.active { background: #FFD700; border-color: #DAA520; }
        #info {
            position: absolute; top: 20px; right: 20px;
            color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            text-align: right; font-size: 14px; z-index: 10;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>ğŸ¢ è¿‡å±±è½¦</div>
        <div>é€Ÿåº¦: <span id="speed">0</span> km/h</div>
        <div>è½¨é“: <span id="trackName">é©¬å½¢</span></div>
    </div>
    <div id="info">
        <div>é¼ æ ‡æ‹–åŠ¨æ—‹è½¬è§†è§’</div>
        <div>æ»šè½®ç¼©æ”¾</div>
        <div>1/2 åˆ‡æ¢è§†è§’</div>
    </div>
    <div id="controls">
        <button id="startBtn">å¯åŠ¨</button>
        <button id="horseBtn" class="active">ğŸ´ é©¬å½¢è½¨é“</button>
        <button id="dragonBtn">ğŸ‰ é¾™å½¢è½¨é“</button>
        <button id="viewBtn">åˆ‡æ¢è§†è§’</button>
        <button id="musicBtn">ğŸ”‡ éŸ³ä¹</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ========== éŸ³ä¹ ==========
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let musicSrc = null, isMusicOn = false;
        function makeMusic() {
            if (musicSrc) musicSrc.stop();
            const dur = 8, sr = audioCtx.sampleRate;
            const buf = audioCtx.createBuffer(2, dur * sr, sr);
            // æ¬¢å¿«çš„æ¸¸ä¹å›­æ³¢å°”å¡é£æ ¼
            const melody = [
                523,523,659,523,784,740,  // C C E C G F#
                659,523,523,659,784,880,  // E C C E G A
                784,659,523,659,523,440,  // G E C E C A
                494,523,587,659,587,523   // B C D E D C
            ];
            const bass = [
                262,330,262,330,349,330,
                262,330,262,330,349,392,
                349,330,262,330,262,220,
                247,262,294,330,294,262
            ];
            const nd = dur / melody.length;
            for (let ch = 0; ch < 2; ch++) {
                const d = buf.getChannelData(ch);
                for (let i = 0; i < d.length; i++) {
                    const t = i / sr;
                    const idx = Math.floor(t / nd) % melody.length;
                    const nt = t % nd;
                    const env = Math.exp(-nt * 4) * 0.7 + 0.3;
                    // å¼¹è·³èŠ‚æ‹
                    const beat = (Math.floor(t * 4) % 2 === 0) ? 1.0 : 0.7;
                    // ä¸»æ—‹å¾‹ï¼ˆæ˜äº®ï¼‰
                    const m = Math.sin(2*Math.PI*melody[idx]*t) * 0.10;
                    // é«˜å…«åº¦æ³›éŸ³
                    const h = Math.sin(2*Math.PI*melody[idx]*2*t) * 0.03 * Math.exp(-nt*6);
                    // ä½éŸ³ä¼´å¥
                    const b = Math.sin(2*Math.PI*bass[idx]*t) * 0.05;
                    // æ‰“å‡»èŠ‚æ‹
                    const perc = Math.random() * 0.02 * Math.exp(-nt*20) * ((Math.floor(t*8)%2===0)?1:0);
                    d[i] = (m + h + b + perc) * env * beat;
                }
            }
            musicSrc = audioCtx.createBufferSource();
            musicSrc.buffer = buf; musicSrc.loop = true;
            musicSrc.connect(audioCtx.destination);
            return musicSrc;
        }
        function toggleMusic() {
            if (isMusicOn) { if(musicSrc) musicSrc.stop(); document.getElementById('musicBtn').textContent='ğŸ”‡ éŸ³ä¹'; }
            else { makeMusic().start(0); document.getElementById('musicBtn').textContent='ğŸ”Š éŸ³ä¹'; }
            isMusicOn = !isMusicOn;
        }

        // ========== åœºæ™¯ ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x4a90d9);
        scene.fog = new THREE.FogExp2(0x4a90d9, 0.005);

        const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
        camera.position.set(40, 30, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // å…‰ç…§
        scene.add(new THREE.AmbientLight(0x404060, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffeedd, 1.0);
        dirLight.position.set(30, 50, 30);
        dirLight.castShadow = true;
        scene.add(dirLight);
        // å½©è‰²ç‚¹å…‰æº
        const pLight1 = new THREE.PointLight(0xff4444, 1, 60);
        pLight1.position.set(20, 15, 0);
        scene.add(pLight1);
        const pLight2 = new THREE.PointLight(0x4444ff, 1, 60);
        pLight2.position.set(-20, 15, 0);
        scene.add(pLight2);

        // åœ°é¢
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshLambertMaterial({ color: 0x2d5a27 })
        );
        ground.rotation.x = -Math.PI/2;
        ground.receiveShadow = true;
        scene.add(ground);

        // æ˜Ÿç©º
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for (let i = 0; i < 2000; i++) {
            starPos.push((Math.random()-0.5)*400, Math.random()*150+20, (Math.random()-0.5)*400);
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.3 })));

        // å¤ªé˜³
        const sunGroup = new THREE.Group();
        const sun = new THREE.Mesh(
            new THREE.SphereGeometry(5, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xFFDD00 })
        );
        sunGroup.add(sun);
        // å¤ªé˜³å…‰æ™•
        const glowMat = new THREE.MeshBasicMaterial({ color: 0xFFAA00, transparent: true, opacity: 0.3 });
        const glow1 = new THREE.Mesh(new THREE.SphereGeometry(7, 32, 32), glowMat);
        sunGroup.add(glow1);
        const glow2 = new THREE.Mesh(
            new THREE.SphereGeometry(10, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xFF8800, transparent: true, opacity: 0.1 })
        );
        sunGroup.add(glow2);
        // å¤ªé˜³å…‰èŠ’ï¼ˆå°„çº¿ï¼‰
        for (let i = 0; i < 12; i++) {
            const ray = new THREE.Mesh(
                new THREE.CylinderGeometry(0.1, 0.5, 8, 6),
                new THREE.MeshBasicMaterial({ color: 0xFFCC00, transparent: true, opacity: 0.4 })
            );
            ray.rotation.z = (i / 12) * Math.PI * 2;
            ray.position.set(Math.cos(ray.rotation.z) * 9, Math.sin(ray.rotation.z) * 9, 0);
            sunGroup.add(ray);
        }
        sunGroup.position.set(80, 80, -60);
        scene.add(sunGroup);
        // å¤ªé˜³å…‰æº
        const sunLight = new THREE.PointLight(0xFFDD88, 1.5, 300);
        sunLight.position.copy(sunGroup.position);
        scene.add(sunLight);

        // ========== è½¨é“ç”Ÿæˆ ==========
        // é©¬å½¢è½¨é“ï¼šå¹³æ»‘çš„é©¬è½®å»“ + å‚ç›´ç¿»è½¬ç¯
        function generateHorseTrack() {
            const N = 1200;
            
            // åŸºç¡€è·¯å¾„
            const basePts = [];
            for (let i = 0; i < N; i++) {
                const t = i / N;
                const a = t * Math.PI * 2;
                const x = 25 * (Math.cos(a) - 0.3*Math.cos(2*a) + 0.1*Math.cos(3*a));
                const z = 20 * (Math.sin(a) + 0.2*Math.sin(2*a));
                // æ›´é™¡å³­çš„é«˜åº¦å˜åŒ–
                const y = 2 +
                    12 * Math.pow(Math.max(0, Math.sin(a - 0.5)), 0.6) +    // é©¬å¤´æ€¥å‡
                    5 * Math.pow(Math.max(0, Math.sin(3*a + 1)), 0.7) +     // èƒŒéƒ¨èµ·ä¼
                    10 * Math.pow(Math.max(0, Math.sin(a + 2.5)), 0.5) +    // è‡€éƒ¨é™¡å‡
                    4 * Math.abs(Math.sin(5*a)) * (1 - Math.cos(a)*0.5);
                basePts.push(new THREE.Vector3(x, y, z));
            }
            const baseCurve = new THREE.CatmullRomCurve3(basePts, true, 'catmullrom', 0.5);

            return insertLoop(baseCurve, N, [{ at: 0.25, radius: 6, range: 0.06 }]);
        }

        // é¾™å½¢è½¨é“
        function generateDragonTrack() {
            const N = 1200;

            const basePts = [];
            for (let i = 0; i < N; i++) {
                const t = i / N;
                const a = t * Math.PI * 2;
                const r = 22 + 8 * Math.sin(3*a);
                const x = r * Math.cos(a + Math.sin(2*a) * 0.3);
                const z = r * Math.sin(a + Math.sin(2*a) * 0.3);
                // æ›´é™¡å³­çš„å‡é™
                const y = 2 +
                    20 * Math.pow(0.5 + 0.5 * Math.sin(a - Math.PI/2), 1.5) +  // é™¡å‡ç¼“é™
                    10 * Math.sin(3*a) * Math.pow(0.5 + 0.5*Math.sin(a), 2) +
                    6 * Math.max(0, Math.sin(5*a - 1));
                basePts.push(new THREE.Vector3(x, y, z));
            }
            const baseCurve = new THREE.CatmullRomCurve3(basePts, true, 'catmullrom', 0.5);

            return insertLoop(baseCurve, N, [
                { at: 0.2, radius: 7, range: 0.055 },
                { at: 0.65, radius: 5, range: 0.045 }
            ]);
        }

        // åœ¨åŸºç¡€æ›²çº¿ä¸Šæ’å…¥å‚ç›´ç¿»è½¬ç¯
        function insertLoop(baseCurve, N, loops) {
            const pts = [];
            for (let i = 0; i < N; i++) {
                const t = i / N;
                let handled = false;

                for (const loop of loops) {
                    const half = loop.range / 2;
                    if (Math.abs(t - loop.at) < half) {
                        const lt = (t - loop.at + half) / loop.range; // 0~1
                        const loopAngle = lt * Math.PI * 2;

                        const centerPt = baseCurve.getPointAt(loop.at);
                        const tangent = baseCurve.getTangentAt(loop.at).normalize();

                        // å‚ç›´ç¿»è½¬ç¯ï¼šæ²¿åˆ‡çº¿æ–¹å‘å‰è¿›ï¼Œæ²¿Yè½´ç”»åœ†
                        const fwd = Math.sin(loopAngle) * loop.radius;
                        const up = (1 - Math.cos(loopAngle)) * loop.radius;

                        pts.push(new THREE.Vector3(
                            centerPt.x + tangent.x * fwd,
                            centerPt.y + up,
                            centerPt.z + tangent.z * fwd
                        ));
                        handled = true;
                        break;
                    }
                }

                if (!handled) pts.push(baseCurve.getPointAt(t));
            }
            // æ›´é«˜é‡‡æ · + ä½å¼ åŠ› = æ›´å¹³æ»‘è¿‡æ¸¡
            return new THREE.CatmullRomCurve3(pts, true, 'catmullrom', 0.2);
        }

        // ========== è½¨é“æ¸²æŸ“ ==========
        let currentCurve = null;
        let trackMesh = null;
        let supportGroup = new THREE.Group();
        scene.add(supportGroup);

        function buildTrack(curve) {
            // ç§»é™¤æ—§è½¨é“
            if (trackMesh) scene.remove(trackMesh);
            while(supportGroup.children.length) supportGroup.remove(supportGroup.children[0]);

            // è½¨é“ç®¡é“
            const tubeGeo = new THREE.TubeGeometry(curve, 500, 0.3, 8, true);
            const tubeMat = new THREE.MeshPhongMaterial({
                color: 0xcc3333, emissive: 0x331111, specular: 0xffffff, shininess: 80
            });
            trackMesh = new THREE.Mesh(tubeGeo, tubeMat);
            trackMesh.castShadow = true;
            scene.add(trackMesh);

            // ç¬¬äºŒæ ¹è½¨é“ï¼ˆå¹³è¡Œï¼‰
            const points2 = [];
            for (let i = 0; i <= 500; i++) {
                const t = i / 500;
                const p = curve.getPointAt(t);
                const tangent = curve.getTangentAt(t);
                const up = new THREE.Vector3(0, 1, 0);
                const right = new THREE.Vector3().crossVectors(tangent, up).normalize();
                points2.push(p.clone().add(right.multiplyScalar(1.5)));
            }
            const curve2 = new THREE.CatmullRomCurve3(points2, true);
            const tube2 = new THREE.Mesh(
                new THREE.TubeGeometry(curve2, 500, 0.3, 8, true),
                tubeMat
            );
            tube2.castShadow = true;
            scene.add(tube2);
            // ä¿å­˜ç¬¬äºŒæ ¹è½¨é“å¼•ç”¨ä»¥ä¾¿æ¸…ç†
            trackMesh.userData.rail2 = tube2;

            // æ”¯æ’‘æŸ±
            const supportMat = new THREE.MeshPhongMaterial({ color: 0x666666 });
            for (let i = 0; i < 40; i++) {
                const t = i / 40;
                const p = curve.getPointAt(t);
                if (p.y > 3) {
                    const h = p.y;
                    const pillar = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.15, 0.2, h, 8),
                        supportMat
                    );
                    pillar.position.set(p.x, h/2, p.z);
                    pillar.castShadow = true;
                    supportGroup.add(pillar);
                }
            }
        }

        // ========== è¿‡å±±è½¦è½¦å¢ï¼ˆ4èŠ‚ï¼‰ ==========
        const carts = [];
        const cartSpacing = 0.012; // è½¦å¢é—´è·ï¼ˆè½¨é“ç™¾åˆ†æ¯”ï¼‰
        const cartColors = [0xFFD700, 0xFF4500, 0x00BFFF, 0x32CD32];

        for (let c = 0; c < 4; c++) {
            const cartGroup = new THREE.Group();

            // è½¦èº«
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 1, 2.5),
                new THREE.MeshPhongMaterial({ color: cartColors[c], emissive: 0x111111 })
            );
            body.castShadow = true;
            cartGroup.add(body);

            // è½¦å¤´è£…é¥°ï¼ˆä»…ç¬¬ä¸€èŠ‚ï¼‰
            if (c === 0) {
                const nose = new THREE.Mesh(
                    new THREE.ConeGeometry(0.7, 1.2, 8),
                    new THREE.MeshPhongMaterial({ color: 0xFF0000 })
                );
                nose.rotation.x = -Math.PI / 2;
                nose.position.z = 1.8;
                cartGroup.add(nose);
            }

            // ä¹˜å®¢ï¼ˆæ¯èŠ‚2äººï¼‰
            for (let s = -1; s <= 1; s += 2) {
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.18, 10, 10),
                    new THREE.MeshPhongMaterial({ color: 0xFFDBAC })
                );
                head.position.set(s * 0.4, 1.0, 0);
                const torso = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.13, 0.16, 0.5, 8),
                    new THREE.MeshPhongMaterial({ color: [0x4169E1, 0xFF69B4, 0x32CD32, 0xFF8C00][c] })
                );
                torso.position.set(s * 0.4, 0.6, 0);
                cartGroup.add(head, torso);
            }

            // è¿æ¥æ†ï¼ˆé™¤ç¬¬ä¸€èŠ‚ï¼‰
            if (c > 0) {
                const link = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 1.5, 6),
                    new THREE.MeshPhongMaterial({ color: 0x888888 })
                );
                link.rotation.x = Math.PI / 2;
                link.position.z = -1.8;
                cartGroup.add(link);
            }

            scene.add(cartGroup);
            carts.push(cartGroup);
        }

        // ========== åœºæ™¯è£…é¥°ï¼šæ ‘æœ¨å’ŒèŠ±è‰ ==========
        function createTree(x, z) {
            const tree = new THREE.Group();
            // æ ‘å¹²
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.35, 3, 8),
                new THREE.MeshPhongMaterial({ color: 0x8B4513 })
            );
            trunk.position.y = 1.5;
            trunk.castShadow = true;
            tree.add(trunk);
            // æ ‘å† ï¼ˆå¤šå±‚ï¼‰
            const leafColors = [0x228B22, 0x2E8B57, 0x006400];
            for (let i = 0; i < 3; i++) {
                const crown = new THREE.Mesh(
                    new THREE.SphereGeometry(1.8 - i * 0.4, 8, 8),
                    new THREE.MeshPhongMaterial({ color: leafColors[i] })
                );
                crown.position.y = 3.5 + i * 1.0;
                crown.castShadow = true;
                tree.add(crown);
            }
            tree.position.set(x, 0, z);
            // éšæœºå¤§å°
            const s = 0.6 + Math.random() * 0.8;
            tree.scale.set(s, s, s);
            return tree;
        }

        function createFlower(x, z) {
            const flower = new THREE.Group();
            // èŒ
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.03, 0.6, 6),
                new THREE.MeshPhongMaterial({ color: 0x228B22 })
            );
            stem.position.y = 0.3;
            flower.add(stem);
            // èŠ±æœµ
            const petalColor = [0xFF69B4, 0xFF4500, 0xFFD700, 0xFF1493, 0x9370DB, 0xFF6347][Math.floor(Math.random()*6)];
            const petal = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                new THREE.MeshPhongMaterial({ color: petalColor, emissive: petalColor, emissiveIntensity: 0.2 })
            );
            petal.position.y = 0.65;
            flower.add(petal);
            flower.position.set(x, 0, z);
            return flower;
        }

        function createBush(x, z) {
            const bush = new THREE.Group();
            for (let i = 0; i < 3; i++) {
                const ball = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4 + Math.random()*0.3, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x3CB371 })
                );
                ball.position.set((Math.random()-0.5)*0.6, 0.3, (Math.random()-0.5)*0.6);
                ball.castShadow = true;
                bush.add(ball);
            }
            bush.position.set(x, 0, z);
            return bush;
        }

        // ç§æ¤æ ‘æœ¨ï¼ˆé¿å¼€è½¨é“åŒºåŸŸï¼‰
        for (let i = 0; i < 40; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 35 + Math.random() * 50;
            scene.add(createTree(Math.cos(angle)*dist, Math.sin(angle)*dist));
        }
        // è½¨é“é™„è¿‘çš„æ ‘
        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 28 + Math.random() * 8;
            scene.add(createTree(Math.cos(angle)*dist, Math.sin(angle)*dist));
        }

        // ç§æ¤èŠ±è‰
        for (let i = 0; i < 100; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 5 + Math.random() * 80;
            scene.add(createFlower(Math.cos(angle)*dist, Math.sin(angle)*dist));
        }

        // çŒæœ¨ä¸›
        for (let i = 0; i < 30; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 40;
            scene.add(createBush(Math.cos(angle)*dist, Math.sin(angle)*dist));
        }

        // ========== çŠ¶æ€ ==========
        let isRunning = false;
        let progress = 0;
        let gameSpeed = 0;
        let maxSpeed = 0.002;
        let currentTrack = 'horse';
        let isFirstPerson = false;

        // åˆå§‹åŒ–é©¬å½¢è½¨é“
        currentCurve = generateHorseTrack();
        buildTrack(currentCurve);

        // ========== æ§åˆ¶ ==========
        document.getElementById('musicBtn').addEventListener('click', toggleMusic);

        document.getElementById('startBtn').addEventListener('click', () => {
            isRunning = !isRunning;
            document.getElementById('startBtn').textContent = isRunning ? 'åœæ­¢' : 'å¯åŠ¨';
            if (isRunning && !isMusicOn) toggleMusic();
        });

        document.getElementById('horseBtn').addEventListener('click', () => {
            if (currentTrack === 'horse') return;
            currentTrack = 'horse';
            if (trackMesh && trackMesh.userData.rail2) scene.remove(trackMesh.userData.rail2);
            currentCurve = generateHorseTrack();
            buildTrack(currentCurve);
            progress = 0;
            document.getElementById('horseBtn').classList.add('active');
            document.getElementById('dragonBtn').classList.remove('active');
            document.getElementById('trackName').textContent = 'é©¬å½¢';
        });

        document.getElementById('dragonBtn').addEventListener('click', () => {
            if (currentTrack === 'dragon') return;
            currentTrack = 'dragon';
            if (trackMesh && trackMesh.userData.rail2) scene.remove(trackMesh.userData.rail2);
            currentCurve = generateDragonTrack();
            buildTrack(currentCurve);
            progress = 0;
            document.getElementById('dragonBtn').classList.add('active');
            document.getElementById('horseBtn').classList.remove('active');
            document.getElementById('trackName').textContent = 'é¾™å½¢';
        });

        document.getElementById('viewBtn').addEventListener('click', () => {
            isFirstPerson = !isFirstPerson;
            document.getElementById('viewBtn').textContent = isFirstPerson ? 'ç¬¬ä¸‰äººç§°' : 'åˆ‡æ¢è§†è§’';
        });

        // é”®ç›˜
        document.addEventListener('keydown', e => {
            if (e.key === '1') { isFirstPerson = false; }
            if (e.key === '2') { isFirstPerson = true; }
        });

        // é¼ æ ‡è§†è§’
        let isDragging = false, prevMouse = { x: 0, y: 0 };
        const lookTarget = new THREE.Vector3(0, 10, 0);
        let camAngleH = Math.PI/4, camAngleV = 0.5, camDist = 50;

        renderer.domElement.addEventListener('mousedown', e => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        renderer.domElement.addEventListener('mousemove', e => {
            if (!isDragging || isFirstPerson) return;
            camAngleH -= (e.clientX - prevMouse.x) * 0.005;
            camAngleV = Math.max(0.1, Math.min(1.4, camAngleV + (e.clientY - prevMouse.y) * 0.005));
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('wheel', e => {
            e.preventDefault();
            if (!isFirstPerson) camDist = Math.max(15, Math.min(100, camDist + e.deltaY * 0.05));
        });

        // ========== åŠ¨ç”» ==========
        function animate() {
            requestAnimationFrame(animate);

            if (isRunning && currentCurve) {
                // æ ¹æ®é«˜åº¦å˜åŒ–è°ƒæ•´é€Ÿåº¦ï¼ˆé‡åŠ›æ•ˆæœï¼‰
                const p1 = currentCurve.getPointAt(progress);
                const nextProgress = (progress + 0.001) % 1;
                const p2 = currentCurve.getPointAt(nextProgress);
                const heightDiff = p2.y - p1.y;

                // ä¸‹å¡åŠ é€Ÿï¼Œä¸Šå¡å‡é€Ÿ
                const gravity = -heightDiff * 0.0003;
                gameSpeed = Math.max(0.0005, Math.min(0.004, gameSpeed + gravity));

                progress = (progress + gameSpeed) % 1;

                // æ›´æ–°4èŠ‚è½¦å¢ä½ç½®å’Œæœå‘
                for (let c = 0; c < 4; c++) {
                    const t = (progress - c * cartSpacing + 1) % 1;
                    const pos = currentCurve.getPointAt(t);
                    const lookT = (t + 0.005) % 1;
                    const lookAt = currentCurve.getPointAt(lookT);

                    carts[c].position.copy(pos);
                    carts[c].position.y += 0.8;
                    carts[c].lookAt(lookAt.x, lookAt.y + 0.8, lookAt.z);
                }

                // é€Ÿåº¦æ˜¾ç¤º
                const displaySpeed = Math.round(gameSpeed * 50000);
                document.getElementById('speed').textContent = displaySpeed;

                // ç¬¬ä¸€äººç§°ç›¸æœºè·Ÿéšç¬¬ä¸€èŠ‚è½¦å¢
                if (isFirstPerson) {
                    const t = progress;
                    const pos = currentCurve.getPointAt(t);
                    const lookT = (t + 0.01) % 1;
                    const lookAt = currentCurve.getPointAt(lookT);
                    camera.position.set(pos.x, pos.y + 2, pos.z);
                    camera.lookAt(lookAt.x, lookAt.y + 1.5, lookAt.z);
                }
            } else {
                gameSpeed = 0.001;
            }

            if (!isFirstPerson) {
                // ç¬¬ä¸‰äººç§°ç›¸æœº
                const target = isRunning ? carts[0].position.clone() : new THREE.Vector3(0, 10, 0);
                lookTarget.lerp(target, 0.05);
                camera.position.set(
                    lookTarget.x + Math.sin(camAngleH) * Math.cos(camAngleV) * camDist,
                    lookTarget.y + Math.sin(camAngleV) * camDist,
                    lookTarget.z + Math.cos(camAngleH) * Math.cos(camAngleV) * camDist
                );
                camera.lookAt(lookTarget);
            }

            // ç¯å…‰åŠ¨ç”»
            const time = Date.now() * 0.001;
            pLight1.position.x = Math.sin(time * 0.5) * 25;
            pLight2.position.z = Math.cos(time * 0.3) * 25;
            // å¤ªé˜³å…‰èŠ’æ—‹è½¬
            sunGroup.rotation.z = time * 0.1;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        animate();
    </script>
</body>
</html>
