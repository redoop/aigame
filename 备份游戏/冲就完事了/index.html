<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂÜ≤Â∞±ÂÆå‰∫ã‰∫ÜÊ®°ÊãüÂô®</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: Arial, sans-serif; cursor: crosshair; }
        #ui {
            position: absolute; top: 15px; left: 15px; z-index: 10;
            color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); font-size: 15px; line-height: 1.8;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            width: 30px; height: 30px; border: 2px solid rgba(255,255,255,0.6);
            border-radius: 50%; z-index: 10; pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.6);
        }
        #crosshair::before { width: 2px; height: 10px; top: 50%; left: 50%; transform: translate(-50%,-50%); }
        #crosshair::after { width: 10px; height: 2px; top: 50%; left: 50%; transform: translate(-50%,-50%); }
        #progressBar {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 24px; background: rgba(0,0,0,0.5);
            border: 2px solid #888; border-radius: 12px; overflow: hidden; z-index: 10;
        }
        #progressFill {
            height: 100%; width: 0%; background: linear-gradient(90deg, #00AAFF, #00FF88);
            border-radius: 10px; transition: width 0.2s;
        }
        #progressText {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            width: 300px; text-align: center; color: white; font-size: 13px;
            font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 11; line-height: 24px;
        }
        #waterBar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 16px; background: rgba(0,0,0,0.5);
            border: 2px solid #666; border-radius: 8px; overflow: hidden; z-index: 10;
        }
        #waterFill { height: 100%; width: 100%; background: #0088FF; border-radius: 6px; }
        #waterLabel {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: #88CCFF; font-size: 12px; z-index: 10; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        #splash {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            font-size: 48px; color: #00FF88; font-weight: bold;
            text-shadow: 0 0 20px #00FF88; z-index: 20;
            pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }
        #levelSelect {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.85); padding: 30px; border-radius: 20px;
            text-align: center; z-index: 30; color: white;
        }
        #levelSelect h2 { font-size: 32px; margin-bottom: 20px; color: #00AAFF; }
        .lvlBtn {
            display: inline-block; margin: 8px; padding: 15px 25px; font-size: 16px;
            background: linear-gradient(135deg, #0066CC, #0099FF); color: white;
            border: none; border-radius: 10px; cursor: pointer; transition: all 0.2s;
        }
        .lvlBtn:hover { transform: scale(1.1); background: linear-gradient(135deg, #0088FF, #00BBFF); }
        .lvlBtn .emoji { font-size: 28px; display: block; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="ui">
        <div>üî´ ÂÜ≤Â∞±ÂÆå‰∫ã‰∫Ü</div>
        <div>Ê∏ÖÊ¥ÅÂ∫¶: <span id="clean">0</span>%</div>
        <div>ËØÑ‰ª∑: <span id="rating">‚≠ê</span></div>
    </div>
    <div id="crosshair"></div>
    <div id="progressBar"><div id="progressFill"></div></div>
    <div id="progressText">Ê∏ÖÊ¥ÅËøõÂ∫¶ 0%</div>
    <div id="waterBar"><div id="waterFill"></div></div>
    <div id="waterLabel">üíß Ê∞¥Âéã</div>
    <div id="splash"></div>
    <div id="levelSelect">
        <h2>üöø ÂÜ≤Â∞±ÂÆå‰∫ã‰∫ÜÊ®°ÊãüÂô®</h2>
        <p style="margin-bottom:20px;color:#aaa">ÈÄâÊã©Ë¶ÅÊ∏ÖÊ¥óÁöÑÂú∫ÊôØ</p>
        <button class="lvlBtn" onclick="startLevel('car')"><span class="emoji">üöó</span>ËÑèËΩ¶</button>
        <button class="lvlBtn" onclick="startLevel('house')"><span class="emoji">üè†</span>ÊàøÂ±ã</button>
        <button class="lvlBtn" onclick="startLevel('playground')"><span class="emoji">üé°</span>Ê∏∏‰πêÂú∫</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ========== Èü≥Êïà ==========
        const AC = new (window.AudioContext || window.webkitAudioContext)();
        function playWater() {
            const buf = AC.createBuffer(1, AC.sampleRate*0.1, AC.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random()-0.5)*0.15*Math.exp(-i/d.length*3);
            const s = AC.createBufferSource(); s.buffer = buf; s.connect(AC.destination); s.start();
        }
        function playClean() {
            const o = AC.createOscillator(), g = AC.createGain();
            o.type = 'sine'; o.frequency.setValueAtTime(800, AC.currentTime);
            o.frequency.exponentialRampToValueAtTime(1200, AC.currentTime+0.1);
            g.gain.setValueAtTime(0.15, AC.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, AC.currentTime+0.15);
            o.connect(g); g.connect(AC.destination); o.start(); o.stop(AC.currentTime+0.15);
        }
        function playComplete() {
            [523,659,784,1047].forEach((f,i) => {
                const o = AC.createOscillator(), g = AC.createGain();
                o.type = 'sine'; o.frequency.value = f;
                g.gain.setValueAtTime(0.2, AC.currentTime+i*0.15);
                g.gain.exponentialRampToValueAtTime(0.01, AC.currentTime+i*0.15+0.3);
                o.connect(g); g.connect(AC.destination);
                o.start(AC.currentTime+i*0.15); o.stop(AC.currentTime+i*0.15+0.3);
            });
        }

        // ========== Âú∫ÊôØ ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88bbee);

        const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500);
        camera.position.set(0, 3, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sunLight = new THREE.DirectionalLight(0xffeedd, 1);
        sunLight.position.set(10, 20, 10); sunLight.castShadow = true;
        scene.add(sunLight);

        // Âú∞Èù¢
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 50),
            new THREE.MeshLambertMaterial({ color: 0x888888 })
        );
        ground.rotation.x = -Math.PI/2; ground.receiveShadow = true;
        scene.add(ground);

        // ========== Ê∞¥Êû™Â∞ÑÁ∫øÂíåÁ≤íÂ≠ê ==========
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const waterParticles = [];

        function spawnWaterParticle(pos, normal) {
            const p = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 4, 4),
                new THREE.MeshBasicMaterial({ color: 0x44BBFF, transparent: true, opacity: 0.8 })
            );
            p.position.copy(pos);
            scene.add(p);
            waterParticles.push({
                mesh: p,
                vx: normal.x * 0.05 + (Math.random()-0.5)*0.03,
                vy: normal.y * 0.03 + Math.random()*0.04,
                vz: normal.z * 0.05 + (Math.random()-0.5)*0.03,
                life: 1
            });
        }

        // Ê∞¥Êü±Â∞ÑÁ∫øÂèØËßÜÂåñ
        const waterBeamGeo = new THREE.CylinderGeometry(0.015, 0.005, 1, 6);
        const waterBeamMat = new THREE.MeshBasicMaterial({ color: 0x44CCFF, transparent: true, opacity: 0.6 });
        const waterBeam = new THREE.Mesh(waterBeamGeo, waterBeamMat);
        waterBeam.visible = false;
        scene.add(waterBeam);

        // ========== ËÑèÊ±°Á≥ªÁªü ==========
        const dirtySpots = [];
        let totalSpots = 0, cleanedSpots = 0;

        function addDirtySpot(mesh, localPos, size) {
            const spot = new THREE.Mesh(
                new THREE.PlaneGeometry(size, size),
                new THREE.MeshBasicMaterial({
                    color: 0x554422, transparent: true, opacity: 0.7,
                    side: THREE.DoubleSide, depthWrite: false
                })
            );
            // ËÆ°ÁÆóÊ≥ïÁ∫øÊñπÂêë
            const worldPos = localPos.clone();
            const dir = worldPos.clone().normalize();
            spot.position.copy(worldPos.clone().add(dir.clone().multiplyScalar(0.01)));
            spot.lookAt(worldPos.clone().add(dir));

            mesh.add(spot);
            dirtySpots.push({ mesh: spot, parent: mesh, hp: 3 + Math.floor(Math.random()*3), cleaned: false });
            totalSpots++;
        }

        // ========== ÂÖ≥Âç°ÁîüÊàê ==========
        let targetObjects = [];

        function clearLevel() {
            targetObjects.forEach(o => scene.remove(o));
            targetObjects = [];
            dirtySpots.forEach(s => { if(s.mesh.parent) s.mesh.parent.remove(s.mesh); });
            dirtySpots.length = 0;
            totalSpots = 0; cleanedSpots = 0;
        }

        function buildCar() {
            clearLevel();
            const car = new THREE.Group();
            // ËΩ¶Ë∫´
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.2, 2),
                new THREE.MeshPhongMaterial({ color: 0xCC2222 })
            );
            body.position.y = 0.8; body.castShadow = true;
            car.add(body);
            // ËΩ¶È°∂
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.8, 1.8),
                new THREE.MeshPhongMaterial({ color: 0xBB1111 })
            );
            roof.position.y = 1.8; roof.castShadow = true;
            car.add(roof);
            // ËΩÆÂ≠ê
            for (let x = -1; x <= 1; x += 2) {
                for (let z = -1; z <= 1; z += 2) {
                    const wheel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.35, 0.35, 0.2, 16),
                        new THREE.MeshPhongMaterial({ color: 0x222222 })
                    );
                    wheel.rotation.x = Math.PI/2;
                    wheel.position.set(x*1.5, 0.35, z*1.1);
                    car.add(wheel);
                }
            }
            // ËΩ¶Á™ó
            const windshield = new THREE.Mesh(
                new THREE.PlaneGeometry(1.8, 0.6),
                new THREE.MeshPhongMaterial({ color: 0x88CCFF, transparent: true, opacity: 0.5 })
            );
            windshield.position.set(1.26, 1.6, 0);
            windshield.rotation.y = Math.PI/2;
            car.add(windshield);

            car.position.y = 0;
            scene.add(car);
            targetObjects.push(car);

            // Ê∑ªÂä†ËÑèÊ±°
            [body, roof].forEach(part => {
                for (let i = 0; i < 40; i++) {
                    const x = (Math.random()-0.5) * (part === body ? 3.8 : 2.3);
                    const y = (Math.random()-0.5) * (part === body ? 1 : 0.6);
                    const z = (Math.random()-0.5) * 1.8;
                    addDirtySpot(part, new THREE.Vector3(x, y, z), 0.3 + Math.random()*0.4);
                }
            });

            camera.position.set(0, 3, 6);
        }

        function buildHouse() {
            clearLevel();
            const house = new THREE.Group();
            // Â¢ôÂ£Å
            const walls = new THREE.Mesh(
                new THREE.BoxGeometry(5, 3, 4),
                new THREE.MeshPhongMaterial({ color: 0xDDCCAA })
            );
            walls.position.y = 1.5; walls.castShadow = true;
            house.add(walls);
            // Â±ãÈ°∂
            const roofGeo = new THREE.ConeGeometry(3.8, 2, 4);
            const roof = new THREE.Mesh(roofGeo, new THREE.MeshPhongMaterial({ color: 0xAA4444 }));
            roof.position.y = 4; roof.rotation.y = Math.PI/4; roof.castShadow = true;
            house.add(roof);
            // Èó®
            const door = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 1.5),
                new THREE.MeshPhongMaterial({ color: 0x664422 })
            );
            door.position.set(0, 0.75, 2.01);
            house.add(door);

            scene.add(house);
            targetObjects.push(house);

            // ËÑèÊ±°
            [walls, roof].forEach(part => {
                const count = part === walls ? 60 : 30;
                for (let i = 0; i < count; i++) {
                    const s = part === walls ? 
                        new THREE.Vector3((Math.random()-0.5)*4.8, (Math.random()-0.5)*2.8, (Math.random()-0.5)*3.8) :
                        new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*1.5, (Math.random()-0.5)*3);
                    addDirtySpot(part, s, 0.3 + Math.random()*0.5);
                }
            });

            camera.position.set(0, 4, 10);
        }

        function buildPlayground() {
            clearLevel();
            const pg = new THREE.Group();
            // ÊªëÊ¢Ø
            const slide = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.1, 3),
                new THREE.MeshPhongMaterial({ color: 0xFF6600 })
            );
            slide.position.set(-2, 1.5, 0); slide.rotation.x = 0.3; slide.castShadow = true;
            pg.add(slide);
            // ÊªëÊ¢ØÊîØÊû∂
            const pole1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,3,8), new THREE.MeshPhongMaterial({color:0x888888}));
            pole1.position.set(-2, 1, -1.2); pg.add(pole1);
            const pole2 = pole1.clone(); pole2.position.set(-2, 1, 1.2); pg.add(pole2);
            // ÁßãÂçÉ
            const swingBar = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 3, 8),
                new THREE.MeshPhongMaterial({ color: 0x666666 })
            );
            swingBar.rotation.x = Math.PI/2; swingBar.position.set(2, 3, 0);
            pg.add(swingBar);
            // ÁßãÂçÉÊîØÊû∂
            for (let z = -1; z <= 1; z += 2) {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,3.2,8), new THREE.MeshPhongMaterial({color:0x666666}));
                leg.position.set(2, 1.5, z*1.5); leg.rotation.z = 0.1*z;
                pg.add(leg);
            }
            // Ë∑∑Ë∑∑Êùø
            const seesaw = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.15, 0.6),
                new THREE.MeshPhongMaterial({ color: 0x44AA44 })
            );
            seesaw.position.set(0, 0.5, 3); seesaw.rotation.z = 0.1;
            pg.add(seesaw);

            scene.add(pg);
            targetObjects.push(pg);

            // ËÑèÊ±°
            [slide, swingBar, seesaw].forEach(part => {
                for (let i = 0; i < 25; i++) {
                    const s = new THREE.Vector3((Math.random()-0.5)*1, (Math.random()-0.5)*0.5, (Math.random()-0.5)*2.5);
                    addDirtySpot(part, s, 0.2 + Math.random()*0.3);
                }
            });

            camera.position.set(0, 4, 10);
        }

        // ========== Ê∏∏ÊàèÁä∂ÊÄÅ ==========
        let isPlaying = false, isSpraying = false;
        let waterPressure = 100;
        const keys = {};

        function startLevel(type) {
            document.getElementById('levelSelect').style.display = 'none';
            if (type === 'car') buildCar();
            else if (type === 'house') buildHouse();
            else buildPlayground();
            isPlaying = true;
            waterPressure = 100;
            renderer.domElement.requestPointerLock();
        }

        // Èº†Ê†áÊéßÂà∂
        let camYaw = 0, camPitch = 0;
        document.addEventListener('mousemove', e => {
            if (!isPlaying) return;
            if (document.pointerLockElement) {
                camYaw -= e.movementX * 0.003;
                camPitch -= e.movementY * 0.003;
                camPitch = Math.max(-1.2, Math.min(1.2, camPitch));
            }
        });

        document.addEventListener('mousedown', () => { isSpraying = true; });
        document.addEventListener('mouseup', () => { isSpraying = false; });
        renderer.domElement.addEventListener('click', () => {
            if (isPlaying && !document.pointerLockElement) renderer.domElement.requestPointerLock();
        });

        document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // ========== Âä®Áîª ==========
        let waterSoundTimer = 0;

        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                // WASDÁßªÂä®
                const moveSpeed = 0.08;
                const forward = new THREE.Vector3(-Math.sin(camYaw), 0, -Math.cos(camYaw));
                const right = new THREE.Vector3(-Math.cos(camYaw), 0, Math.sin(camYaw));
                if (keys['w']) camera.position.add(forward.clone().multiplyScalar(moveSpeed));
                if (keys['s']) camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
                if (keys['a']) camera.position.add(right.clone().multiplyScalar(-moveSpeed));
                if (keys['d']) camera.position.add(right.clone().multiplyScalar(moveSpeed));

                // Áõ∏Êú∫ÊúùÂêë
                const lookDir = new THREE.Vector3(
                    -Math.sin(camYaw) * Math.cos(camPitch),
                    Math.sin(camPitch),
                    -Math.cos(camYaw) * Math.cos(camPitch)
                );
                camera.lookAt(camera.position.clone().add(lookDir));

                // Âñ∑Ê∞¥
                if (isSpraying && waterPressure > 0) {
                    waterPressure = Math.max(0, waterPressure - 0.15);

                    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                    const intersects = raycaster.intersectObjects(scene.children, true);

                    if (intersects.length > 0) {
                        const hit = intersects[0];

                        // Ê∞¥Êü±
                        waterBeam.visible = true;
                        const mid = camera.position.clone().add(hit.point).multiplyScalar(0.5);
                        waterBeam.position.copy(mid);
                        waterBeam.scale.y = camera.position.distanceTo(hit.point);
                        waterBeam.lookAt(hit.point);
                        waterBeam.rotateX(Math.PI/2);

                        // Ê∞¥Ëä±Á≤íÂ≠ê
                        for (let i = 0; i < 3; i++) {
                            spawnWaterParticle(hit.point, hit.face ? hit.face.normal : new THREE.Vector3(0,1,0));
                        }

                        // Ê∏ÖÊ¥óËÑèÊ±°
                        dirtySpots.forEach(spot => {
                            if (spot.cleaned) return;
                            const spotWorld = new THREE.Vector3();
                            spot.mesh.getWorldPosition(spotWorld);
                            if (spotWorld.distanceTo(hit.point) < 0.5) {
                                spot.hp--;
                                spot.mesh.material.opacity = (spot.hp / 6) * 0.7;
                                if (spot.hp <= 0) {
                                    spot.cleaned = true;
                                    spot.mesh.visible = false;
                                    cleanedSpots++;
                                    playClean();
                                }
                            }
                        });

                        waterSoundTimer -= 0.016;
                        if (waterSoundTimer <= 0) { playWater(); waterSoundTimer = 0.1; }
                    }
                } else {
                    waterBeam.visible = false;
                }

                // Ê∞¥ÂéãÊÅ¢Â§ç
                if (!isSpraying) waterPressure = Math.min(100, waterPressure + 0.3);

                // Êõ¥Êñ∞Á≤íÂ≠ê
                for (let i = waterParticles.length-1; i >= 0; i--) {
                    const p = waterParticles[i];
                    p.mesh.position.x += p.vx;
                    p.mesh.position.y += p.vy;
                    p.mesh.position.z += p.vz;
                    p.vy -= 0.003;
                    p.life -= 0.04;
                    p.mesh.material.opacity = p.life * 0.8;
                    if (p.life <= 0) { scene.remove(p.mesh); waterParticles.splice(i, 1); }
                }

                // ËøõÂ∫¶
                const pct = totalSpots > 0 ? Math.round(cleanedSpots / totalSpots * 100) : 0;
                document.getElementById('clean').textContent = pct;
                document.getElementById('progressFill').style.width = pct + '%';
                document.getElementById('progressText').textContent = 'Ê∏ÖÊ¥ÅËøõÂ∫¶ ' + pct + '%';
                document.getElementById('waterFill').style.width = waterPressure + '%';

                // ËØÑ‰ª∑
                const rating = pct >= 100 ? '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê ÂÆåÁæé!' :
                               pct >= 80 ? '‚≠ê‚≠ê‚≠ê‚≠ê' :
                               pct >= 60 ? '‚≠ê‚≠ê‚≠ê' :
                               pct >= 30 ? '‚≠ê‚≠ê' : '‚≠ê';
                document.getElementById('rating').textContent = rating;

                // ÂÆåÊàê
                if (pct >= 100) {
                    const el = document.getElementById('splash');
                    if (el.style.opacity !== '1') {
                        el.textContent = '‚ú® ÂÜ≤ÂÆå‰∫Ü! ÂÆåÁæéÊ∏ÖÊ¥Å! ‚ú®';
                        el.style.opacity = 1;
                        playComplete();
                        setTimeout(() => {
                            el.style.opacity = 0;
                            document.getElementById('levelSelect').style.display = 'block';
                            document.exitPointerLock();
                            isPlaying = false;
                        }, 3000);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth/innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        animate();
    </script>
</body>
</html>
