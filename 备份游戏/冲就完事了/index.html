<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å†²å°±å®Œäº‹äº†æ¨¡æ‹Ÿå™¨</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: Arial, sans-serif; cursor: crosshair; }
        #ui {
            position: absolute; top: 15px; left: 15px; z-index: 10;
            color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); font-size: 15px; line-height: 1.8;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            width: 30px; height: 30px; border: 2px solid rgba(255,255,255,0.6);
            border-radius: 50%; z-index: 10; pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.6);
        }
        #crosshair::before { width: 2px; height: 10px; top: 50%; left: 50%; transform: translate(-50%,-50%); }
        #crosshair::after { width: 10px; height: 2px; top: 50%; left: 50%; transform: translate(-50%,-50%); }
        #progressBar {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            width: 300px; height: 24px; background: rgba(0,0,0,0.5);
            border: 2px solid #888; border-radius: 12px; overflow: hidden; z-index: 10;
        }
        #progressFill {
            height: 100%; width: 0%; background: linear-gradient(90deg, #00AAFF, #00FF88);
            border-radius: 10px; transition: width 0.2s;
        }
        #progressText {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            width: 300px; text-align: center; color: white; font-size: 13px;
            font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 11; line-height: 24px;
        }
        #waterBar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 16px; background: rgba(0,0,0,0.5);
            border: 2px solid #666; border-radius: 8px; overflow: hidden; z-index: 10;
        }
        #waterFill { height: 100%; width: 100%; background: #0088FF; border-radius: 6px; }
        #waterLabel {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: #88CCFF; font-size: 12px; z-index: 10; text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        #viewToggle {
            position: absolute; bottom: 15px; right: 15px; z-index: 10;
            padding: 10px 20px; background: rgba(0,0,0,0.6); color: white;
            border: 2px solid #00AAFF; border-radius: 8px; font-size: 14px;
            cursor: pointer; transition: all 0.2s;
        }
        #viewToggle:hover { background: rgba(0,170,255,0.3); transform: scale(1.05); }
        #gunInfo {
            position: absolute; top: 15px; right: 15px; z-index: 10;
            color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-size: 15px; text-align: right; line-height: 1.8;
        }
        #controls {
            position: absolute; bottom: 60px; right: 15px; z-index: 10;
            background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px;
            color: white; font-size: 13px;
        }
        .ctrlBtn {
            display: block; width: 100%; margin: 5px 0; padding: 8px 15px;
            background: rgba(0,170,255,0.3); color: white; border: 1px solid #00AAFF;
            border-radius: 5px; cursor: pointer; transition: all 0.2s; font-size: 12px;
        }
        .ctrlBtn:hover { background: rgba(0,170,255,0.5); transform: scale(1.05); }
        #splash {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            font-size: 48px; color: #00FF88; font-weight: bold;
            text-shadow: 0 0 20px #00FF88; z-index: 20;
            pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }
        #levelSelect {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.85); padding: 30px; border-radius: 20px;
            text-align: center; z-index: 30; color: white;
        }
        #levelSelect h2 { font-size: 32px; margin-bottom: 20px; color: #00AAFF; }
        .lvlBtn {
            display: inline-block; margin: 8px; padding: 15px 25px; font-size: 16px;
            background: linear-gradient(135deg, #0066CC, #0099FF); color: white;
            border: none; border-radius: 10px; cursor: pointer; transition: all 0.2s;
        }
        .lvlBtn:hover { transform: scale(1.1); background: linear-gradient(135deg, #0088FF, #00BBFF); }
        .lvlBtn .emoji { font-size: 28px; display: block; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="ui">
        <div>ğŸ”« å†²å°±å®Œäº‹äº†</div>
        <div>æ¸…æ´åº¦: <span id="clean">0</span>%</div>
        <div>è¯„ä»·: <span id="rating">â­</span></div>
    </div>
    <div id="crosshair"></div>
    <div id="progressBar"><div id="progressFill"></div></div>
    <div id="progressText">æ¸…æ´è¿›åº¦ 0%</div>
    <div id="waterBar"><div id="waterFill"></div></div>
    <div id="waterLabel">ğŸ’§ æ°´å‹</div>
    <div id="viewToggle">ğŸ“· åˆ‡æ¢è§†è§’ (V)</div>
    <div id="gunInfo">
        <div>ğŸ”« <span id="gunType">æ ‡å‡†æ°´æª</span></div>
        <div style="font-size:12px;color:#aaa">æŒ‰ G åˆ‡æ¢</div>
    </div>
    <div id="controls">
        <div style="margin-bottom:8px;font-weight:bold;text-align:center">âš™ï¸ æ§åˆ¶</div>
        <button class="ctrlBtn" onclick="switchGun()">ğŸ”« åˆ‡æ¢æ°´æª (G)</button>
        <button class="ctrlBtn" onclick="switchView()">ğŸ“· åˆ‡æ¢è§†è§’ (V)</button>
    </div>
    <div id="splash"></div>
    <div id="levelSelect">
        <h2>ğŸš¿ å†²å°±å®Œäº‹äº†æ¨¡æ‹Ÿå™¨</h2>
        <p style="margin-bottom:20px;color:#aaa">é€‰æ‹©è¦æ¸…æ´—çš„åœºæ™¯</p>
        <button class="lvlBtn" onclick="startLevel('car')"><span class="emoji">ğŸš—</span>è„è½¦</button>
        <button class="lvlBtn" onclick="startLevel('house')"><span class="emoji">ğŸ </span>æˆ¿å±‹</button>
        <button class="lvlBtn" onclick="startLevel('playground')"><span class="emoji">ğŸ¡</span>æ¸¸ä¹åœº</button>
        <button class="lvlBtn" onclick="startLevel('robot')"><span class="emoji">ğŸ¤–</span>æœºå™¨äºº</button>
        <button class="lvlBtn" onclick="startLevel('kitchen')"><span class="emoji">ğŸ³</span>å¨æˆ¿</button>
        <button class="lvlBtn" onclick="startLevel('classroom')"><span class="emoji">ğŸ«</span>æ•™å®¤</button>
        <button class="lvlBtn" onclick="startLevel('kfc')"><span class="emoji">ğŸ—</span>è‚¯å¾·åŸº</button>
        <button class="lvlBtn" onclick="startLevel('building')"><span class="emoji">ğŸ¢</span>å¤§å¦</button>
        <button class="lvlBtn" onclick="startLevel('mixue')"><span class="emoji">ğŸ¦</span>èœœé›ªå†°åŸ</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ========== éŸ³æ•ˆ ==========
        const AC = new (window.AudioContext || window.webkitAudioContext)();
        function playWater() {
            const buf = AC.createBuffer(1, AC.sampleRate*0.1, AC.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random()-0.5)*0.15*Math.exp(-i/d.length*3);
            const s = AC.createBufferSource(); s.buffer = buf; s.connect(AC.destination); s.start();
        }
        function playClean() {
            const o = AC.createOscillator(), g = AC.createGain();
            o.type = 'sine'; o.frequency.setValueAtTime(800, AC.currentTime);
            o.frequency.exponentialRampToValueAtTime(1200, AC.currentTime+0.1);
            g.gain.setValueAtTime(0.15, AC.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, AC.currentTime+0.15);
            o.connect(g); g.connect(AC.destination); o.start(); o.stop(AC.currentTime+0.15);
        }
        function playComplete() {
            [523,659,784,1047].forEach((f,i) => {
                const o = AC.createOscillator(), g = AC.createGain();
                o.type = 'sine'; o.frequency.value = f;
                g.gain.setValueAtTime(0.2, AC.currentTime+i*0.15);
                g.gain.exponentialRampToValueAtTime(0.01, AC.currentTime+i*0.15+0.3);
                o.connect(g); g.connect(AC.destination);
                o.start(AC.currentTime+i*0.15); o.stop(AC.currentTime+i*0.15+0.3);
            });
        }
        function playRocket() {
            const o = AC.createOscillator(), g = AC.createGain();
            o.type = 'sawtooth'; 
            o.frequency.setValueAtTime(100, AC.currentTime);
            o.frequency.exponentialRampToValueAtTime(50, AC.currentTime+0.3);
            g.gain.setValueAtTime(0.2, AC.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, AC.currentTime+0.3);
            o.connect(g); g.connect(AC.destination); o.start(); o.stop(AC.currentTime+0.3);
        }
        function playExplosion() {
            const buf = AC.createBuffer(1, AC.sampleRate*0.5, AC.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random()-0.5)*0.3*Math.exp(-i/d.length*5);
            const s = AC.createBufferSource(); s.buffer = buf; s.connect(AC.destination); s.start();
        }
        function playNuke() {
            // ä½é¢‘éš†éš†å£°
            const o1 = AC.createOscillator(), g1 = AC.createGain();
            o1.type = 'sine'; o1.frequency.value = 40;
            g1.gain.setValueAtTime(0.3, AC.currentTime);
            g1.gain.exponentialRampToValueAtTime(0.01, AC.currentTime+2);
            o1.connect(g1); g1.connect(AC.destination); o1.start(); o1.stop(AC.currentTime+2);
            
            // é«˜é¢‘çˆ†ç‚¸å£°
            const buf = AC.createBuffer(1, AC.sampleRate*1, AC.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random()-0.5)*0.5*Math.exp(-i/d.length*3);
            const s = AC.createBufferSource(); s.buffer = buf; s.connect(AC.destination); s.start();
        }

        // ========== åœºæ™¯ ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88bbee);

        const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500);
        camera.position.set(0, 3, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sunLight = new THREE.DirectionalLight(0xffeedd, 1);
        sunLight.position.set(10, 20, 10); sunLight.castShadow = true;
        scene.add(sunLight);

        // åœ°é¢
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 50),
            new THREE.MeshLambertMaterial({ color: 0x888888 })
        );
        ground.rotation.x = -Math.PI/2; ground.receiveShadow = true;
        scene.add(ground);

        // ========== æ°´æªå°„çº¿å’Œç²’å­ ==========
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const waterParticles = [];
        const rockets = [];
        const mushroomClouds = [];

        function spawnWaterParticle(pos, normal, color) {
            const p = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 4, 4),
                new THREE.MeshBasicMaterial({ color: color || 0x44BBFF, transparent: true, opacity: 0.8 })
            );
            p.position.copy(pos);
            scene.add(p);
            waterParticles.push({
                mesh: p,
                vx: normal.x * 0.05 + (Math.random()-0.5)*0.03,
                vy: normal.y * 0.03 + Math.random()*0.04,
                vz: normal.z * 0.05 + (Math.random()-0.5)*0.03,
                life: 1
            });
        }

        // æ°´æŸ±å°„çº¿å¯è§†åŒ–
        const waterBeamGeo = new THREE.CylinderGeometry(0.015, 0.005, 1, 6);
        const waterBeamMat = new THREE.MeshBasicMaterial({ color: 0x44CCFF, transparent: true, opacity: 0.6 });
        const waterBeam = new THREE.Mesh(waterBeamGeo, waterBeamMat);
        waterBeam.visible = false;
        scene.add(waterBeam);

        // ========== è„æ±¡ç³»ç»Ÿ ==========
        const dirtySpots = [];
        let totalSpots = 0, cleanedSpots = 0;

        function addDirtySpot(mesh, localPos, size) {
            const spot = new THREE.Mesh(
                new THREE.PlaneGeometry(size, size),
                new THREE.MeshBasicMaterial({
                    color: 0x332211, transparent: true, opacity: 0.95,
                    side: THREE.DoubleSide, depthWrite: false
                })
            );
            // è®¡ç®—æ³•çº¿æ–¹å‘
            const worldPos = localPos.clone();
            const dir = worldPos.clone().normalize();
            spot.position.copy(worldPos.clone().add(dir.clone().multiplyScalar(0.01)));
            spot.lookAt(worldPos.clone().add(dir));

            mesh.add(spot);
            dirtySpots.push({ mesh: spot, parent: mesh, hp: 3 + Math.floor(Math.random()*3), cleaned: false });
            totalSpots++;
        }

        // ========== å…³å¡ç”Ÿæˆ ==========
        let targetObjects = [];

        function clearLevel() {
            targetObjects.forEach(o => scene.remove(o));
            targetObjects = [];
            dirtySpots.forEach(s => { if(s.mesh.parent) s.mesh.parent.remove(s.mesh); });
            dirtySpots.length = 0;
            totalSpots = 0; cleanedSpots = 0;
            scene.background = new THREE.Color(0x88bbee);
        }

        function buildCar() {
            clearLevel();
            const car = new THREE.Group();
            // è½¦èº«
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1.2, 2),
                new THREE.MeshPhongMaterial({ color: 0xCC2222 })
            );
            body.position.y = 0.8; body.castShadow = true;
            car.add(body);
            // è½¦é¡¶
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 0.8, 1.8),
                new THREE.MeshPhongMaterial({ color: 0xBB1111 })
            );
            roof.position.y = 1.8; roof.castShadow = true;
            car.add(roof);
            // è½®å­
            for (let x = -1; x <= 1; x += 2) {
                for (let z = -1; z <= 1; z += 2) {
                    const wheel = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.35, 0.35, 0.2, 16),
                        new THREE.MeshPhongMaterial({ color: 0x222222 })
                    );
                    wheel.rotation.x = Math.PI/2;
                    wheel.position.set(x*1.5, 0.35, z*1.1);
                    car.add(wheel);
                }
            }
            // è½¦çª—
            const windshield = new THREE.Mesh(
                new THREE.PlaneGeometry(1.8, 0.6),
                new THREE.MeshPhongMaterial({ color: 0x88CCFF, transparent: true, opacity: 0.5 })
            );
            windshield.position.set(1.26, 1.6, 0);
            windshield.rotation.y = Math.PI/2;
            car.add(windshield);

            car.position.y = 0;
            scene.add(car);
            targetObjects.push(car);

            // æ·»åŠ è„æ±¡
            [body, roof].forEach(part => {
                for (let i = 0; i < 40; i++) {
                    const x = (Math.random()-0.5) * (part === body ? 3.8 : 2.3);
                    const y = (Math.random()-0.5) * (part === body ? 1 : 0.6);
                    const z = (Math.random()-0.5) * 1.8;
                    addDirtySpot(part, new THREE.Vector3(x, y, z), 0.4 + Math.random()*0.5);
                }
            });

            camera.position.set(0, 3, 6);
        }

        function buildHouse() {
            clearLevel();
            const house = new THREE.Group();
            // å¢™å£
            const walls = new THREE.Mesh(
                new THREE.BoxGeometry(5, 3, 4),
                new THREE.MeshPhongMaterial({ color: 0xDDCCAA })
            );
            walls.position.y = 1.5; walls.castShadow = true;
            house.add(walls);
            // å±‹é¡¶
            const roofGeo = new THREE.ConeGeometry(3.8, 2, 4);
            const roof = new THREE.Mesh(roofGeo, new THREE.MeshPhongMaterial({ color: 0xAA4444 }));
            roof.position.y = 4; roof.rotation.y = Math.PI/4; roof.castShadow = true;
            house.add(roof);
            // é—¨
            const door = new THREE.Mesh(
                new THREE.PlaneGeometry(0.8, 1.5),
                new THREE.MeshPhongMaterial({ color: 0x664422 })
            );
            door.position.set(0, 0.75, 2.01);
            house.add(door);

            scene.add(house);
            targetObjects.push(house);

            // è„æ±¡
            [walls, roof].forEach(part => {
                const count = part === walls ? 60 : 30;
                for (let i = 0; i < count; i++) {
                    const s = part === walls ? 
                        new THREE.Vector3((Math.random()-0.5)*4.8, (Math.random()-0.5)*2.8, (Math.random()-0.5)*3.8) :
                        new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*1.5, (Math.random()-0.5)*3);
                    addDirtySpot(part, s, 0.4 + Math.random()*0.6);
                }
            });

            camera.position.set(0, 4, 10);
        }

        function buildPlayground() {
            clearLevel();
            const pg = new THREE.Group();
            // æ»‘æ¢¯
            const slide = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.1, 3),
                new THREE.MeshPhongMaterial({ color: 0xFF6600 })
            );
            slide.position.set(-2, 1.5, 0); slide.rotation.x = 0.3; slide.castShadow = true;
            pg.add(slide);
            // æ»‘æ¢¯æ”¯æ¶
            const pole1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,3,8), new THREE.MeshPhongMaterial({color:0x888888}));
            pole1.position.set(-2, 1, -1.2); pg.add(pole1);
            const pole2 = pole1.clone(); pole2.position.set(-2, 1, 1.2); pg.add(pole2);
            // ç§‹åƒ
            const swingBar = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 3, 8),
                new THREE.MeshPhongMaterial({ color: 0x666666 })
            );
            swingBar.rotation.x = Math.PI/2; swingBar.position.set(2, 3, 0);
            pg.add(swingBar);
            // ç§‹åƒæ”¯æ¶
            for (let z = -1; z <= 1; z += 2) {
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,3.2,8), new THREE.MeshPhongMaterial({color:0x666666}));
                leg.position.set(2, 1.5, z*1.5); leg.rotation.z = 0.1*z;
                pg.add(leg);
            }
            // è··è··æ¿
            const seesaw = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.15, 0.6),
                new THREE.MeshPhongMaterial({ color: 0x44AA44 })
            );
            seesaw.position.set(0, 0.5, 3); seesaw.rotation.z = 0.1;
            pg.add(seesaw);

            scene.add(pg);
            targetObjects.push(pg);

            // è„æ±¡
            [slide, swingBar, seesaw].forEach(part => {
                for (let i = 0; i < 25; i++) {
                    const s = new THREE.Vector3((Math.random()-0.5)*1, (Math.random()-0.5)*0.5, (Math.random()-0.5)*2.5);
                    addDirtySpot(part, s, 0.35 + Math.random()*0.4);
                }
            });

            camera.position.set(0, 4, 10);
        }

        function buildRobot() {
            clearLevel();
            const robot = new THREE.Group();
            
            // å¤´éƒ¨
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshPhongMaterial({ color: 0xCCCCCC })
            );
            head.position.y = 2.5; head.castShadow = true;
            robot.add(head);
            
            // çœ¼ç›
            const eye1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                new THREE.MeshPhongMaterial({ color: 0x00FFFF, emissive: 0x0088AA })
            );
            eye1.position.set(-0.25, 2.6, 0.51);
            robot.add(eye1);
            const eye2 = eye1.clone();
            eye2.position.set(0.25, 2.6, 0.51);
            robot.add(eye2);
            
            // èº«ä½“
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2, 1),
                new THREE.MeshPhongMaterial({ color: 0xAAAAAA })
            );
            body.position.y = 1; body.castShadow = true;
            robot.add(body);
            
            // æ‰‹è‡‚
            for (let x = -1; x <= 1; x += 2) {
                const arm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8),
                    new THREE.MeshPhongMaterial({ color: 0x999999 })
                );
                arm.position.set(x * 0.9, 1, 0);
                arm.castShadow = true;
                robot.add(arm);
                
                const hand = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 8, 8),
                    new THREE.MeshPhongMaterial({ color: 0x888888 })
                );
                hand.position.set(x * 0.9, 0.2, 0);
                robot.add(hand);
            }
            
            // è…¿
            for (let x = -1; x <= 1; x += 2) {
                const leg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 1.2, 8),
                    new THREE.MeshPhongMaterial({ color: 0x777777 })
                );
                leg.position.set(x * 0.4, 0.1, 0);
                leg.castShadow = true;
                robot.add(leg);
            }
            
            // å¤©çº¿
            const antenna = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8),
                new THREE.MeshPhongMaterial({ color: 0xFF6600 })
            );
            antenna.position.set(0, 3.25, 0);
            robot.add(antenna);
            
            const antennaBall = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 8, 8),
                new THREE.MeshPhongMaterial({ color: 0xFF0000, emissive: 0x880000 })
            );
            antennaBall.position.set(0, 3.55, 0);
            robot.add(antennaBall);

            scene.add(robot);
            targetObjects.push(robot);

            // è„æ±¡
            [head, body].forEach(part => {
                for (let i = 0; i < 35; i++) {
                    const size = part === head ? 0.9 : 1.4;
                    const s = new THREE.Vector3(
                        (Math.random()-0.5) * size,
                        (Math.random()-0.5) * (part === head ? 0.9 : 1.8),
                        (Math.random()-0.5) * 0.9
                    );
                    addDirtySpot(part, s, 0.3 + Math.random()*0.5);
                }
            });

            camera.position.set(0, 3, 8);
        }

        function buildKitchen() {
            clearLevel();
            const kitchen = new THREE.Group();
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(8, 6), new THREE.MeshPhongMaterial({ color: 0xDDDDDD }));
            floor.rotation.x = -Math.PI/2; floor.position.y = 0.01; kitchen.add(floor);
            const cabinet = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 1), new THREE.MeshPhongMaterial({ color: 0x8B4513 }));
            cabinet.position.set(0, 1, -2.5); cabinet.castShadow = true; kitchen.add(cabinet);
            const counter = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 1.2), new THREE.MeshPhongMaterial({ color: 0x555555 }));
            counter.position.set(0, 2.05, -2.4); counter.castShadow = true; kitchen.add(counter);
            const stove = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.15, 1), new THREE.MeshPhongMaterial({ color: 0x222222 }));
            stove.position.set(-1, 2.15, -2.4); kitchen.add(stove);
            const sink = new THREE.Mesh(new THREE.BoxGeometry(1, 0.3, 0.8), new THREE.MeshPhongMaterial({ color: 0xCCCCCC }));
            sink.position.set(1, 2, -2.4); kitchen.add(sink);
            const fridge = new THREE.Mesh(new THREE.BoxGeometry(1.2, 3, 1), new THREE.MeshPhongMaterial({ color: 0xEEEEEE }));
            fridge.position.set(2.5, 1.5, -2); fridge.castShadow = true; kitchen.add(fridge);
            scene.add(kitchen); targetObjects.push(kitchen);
            [cabinet, counter, stove, sink, fridge, floor].forEach(part => {
                const count = part === floor ? 80 : 40;
                for (let i = 0; i < count; i++) {
                    const box = new THREE.Box3().setFromObject(part); const size = new THREE.Vector3(); box.getSize(size);
                    addDirtySpot(part, new THREE.Vector3((Math.random()-0.5)*size.x*0.9, (Math.random()-0.5)*size.y*0.9, (Math.random()-0.5)*size.z*0.9), 0.3+Math.random()*0.5);
                }
            });
            camera.position.set(0, 3, 5);
        }

        function buildClassroom() {
            clearLevel();
            const classroom = new THREE.Group();
            const blackboard = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 0.1), new THREE.MeshPhongMaterial({ color: 0x1A3A1A }));
            blackboard.position.set(0, 2, -3); blackboard.castShadow = true; classroom.add(blackboard);
            const podium = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 1), new THREE.MeshPhongMaterial({ color: 0xA0522D }));
            podium.position.set(0, 0.5, -2); podium.castShadow = true; classroom.add(podium);
            for (let row = 0; row < 3; row++) {
                for (let col = -1; col <= 1; col += 2) {
                    const desk = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.8), new THREE.MeshPhongMaterial({ color: 0xDEB887 }));
                    desk.position.set(col*1.5, 0.7, 1+row*1.5); desk.castShadow = true; classroom.add(desk);
                }
            }
            scene.add(classroom); targetObjects.push(classroom);
            [blackboard, podium].forEach(part => {
                const count = part === blackboard ? 60 : 40;
                for (let i = 0; i < count; i++) {
                    const box = new THREE.Box3().setFromObject(part); const size = new THREE.Vector3(); box.getSize(size);
                    addDirtySpot(part, new THREE.Vector3((Math.random()-0.5)*size.x*0.9, (Math.random()-0.5)*size.y*0.9, (Math.random()-0.5)*size.z*0.9), 0.25+Math.random()*0.4);
                }
            });
            camera.position.set(0, 3, 6);
        }

        function buildKFC() {
            clearLevel();
            const kfc = new THREE.Group();
            
            // åœ°æ¿
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 8),
                new THREE.MeshPhongMaterial({ color: 0xEEDDCC })
            );
            floor.rotation.x = -Math.PI/2;
            floor.position.y = 0.01;
            kfc.add(floor);
            
            // ç‚¹é¤æŸœå°
            const counter = new THREE.Mesh(
                new THREE.BoxGeometry(5, 1.2, 1),
                new THREE.MeshPhongMaterial({ color: 0xCC0000 })
            );
            counter.position.set(0, 0.6, -3);
            counter.castShadow = true;
            kfc.add(counter);
            
            // æŸœå°å°é¢
            const counterTop = new THREE.Mesh(
                new THREE.BoxGeometry(5, 0.1, 1.2),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            counterTop.position.set(0, 1.25, -3);
            kfc.add(counterTop);
            
            // èœå•æ¿
            const menuBoard = new THREE.Mesh(
                new THREE.BoxGeometry(4, 2.5, 0.1),
                new THREE.MeshPhongMaterial({ color: 0x222222 })
            );
            menuBoard.position.set(0, 2.5, -3.5);
            kfc.add(menuBoard);
            
            // KFCæ ‡å¿—
            const logo = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1.5, 0.15),
                new THREE.MeshPhongMaterial({ color: 0xFF0000, emissive: 0x880000 })
            );
            logo.position.set(0, 4.2, -3.5);
            kfc.add(logo);
            
            // é¤æ¡Œï¼ˆ4å¼ ï¼‰
            for (let row = 0; row < 2; row++) {
                for (let col = -1; col <= 1; col += 2) {
                    const table = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.6, 0.6, 0.05, 16),
                        new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
                    );
                    table.position.set(col * 2, 0.75, 1 + row * 2.5);
                    table.castShadow = true;
                    kfc.add(table);
                    
                    // æ¡Œè…¿
                    const tableLeg = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.12, 0.75, 8),
                        new THREE.MeshPhongMaterial({ color: 0xCCCCCC })
                    );
                    tableLeg.position.set(col * 2, 0.375, 1 + row * 2.5);
                    kfc.add(tableLeg);
                    
                    // æ¤…å­ï¼ˆæ¯æ¡Œ2æŠŠï¼‰
                    for (let side = -1; side <= 1; side += 2) {
                        const chair = new THREE.Mesh(
                            new THREE.BoxGeometry(0.5, 0.05, 0.5),
                            new THREE.MeshPhongMaterial({ color: 0xDD0000 })
                        );
                        chair.position.set(col * 2, 0.45, 1 + row * 2.5 + side * 0.9);
                        kfc.add(chair);
                        
                        const backrest = new THREE.Mesh(
                            new THREE.BoxGeometry(0.5, 0.5, 0.05),
                            new THREE.MeshPhongMaterial({ color: 0xDD0000 })
                        );
                        backrest.position.set(col * 2, 0.7, 1 + row * 2.5 + side * 1.15);
                        kfc.add(backrest);
                    }
                }
            }
            
            // åƒåœ¾æ¡¶
            const trashBin = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.35, 0.8, 8),
                new THREE.MeshPhongMaterial({ color: 0x666666 })
            );
            trashBin.position.set(3.5, 0.4, 2);
            kfc.add(trashBin);
            
            // é¥®æ–™æœº
            const drinkMachine = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.5, 0.6),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            drinkMachine.position.set(-3, 0.75, -2);
            drinkMachine.castShadow = true;
            kfc.add(drinkMachine);
            
            // æ‰˜ç›˜ï¼ˆåœ¨æŸœå°ä¸Šï¼‰
            for (let i = 0; i < 3; i++) {
                const tray = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.02, 0.4),
                    new THREE.MeshPhongMaterial({ color: 0xFF6600 })
                );
                tray.position.set(-1.5 + i * 0.7, 1.32, -3);
                kfc.add(tray);
            }

            scene.add(kfc);
            targetObjects.push(kfc);

            // è„æ±¡
            const dirtyParts = [counter, counterTop, menuBoard, logo, trashBin, drinkMachine, floor];
            dirtyParts.forEach(part => {
                const count = part === floor ? 80 : part === counter ? 50 : part === counterTop ? 60 : 40;
                for (let i = 0; i < count; i++) {
                    const box = new THREE.Box3().setFromObject(part);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    const s = new THREE.Vector3(
                        (Math.random()-0.5) * size.x * 0.9,
                        (Math.random()-0.5) * size.y * 0.9,
                        (Math.random()-0.5) * size.z * 0.9
                    );
                    addDirtySpot(part, s, 0.3 + Math.random()*0.5);
                }
            });
            
            // é¤æ¡Œè„æ±¡
            kfc.children.forEach(child => {
                if (child.geometry && child.geometry.type === 'CylinderGeometry' && child.position.y > 0.7) {
                    for (let i = 0; i < 35; i++) {
                        const s = new THREE.Vector3((Math.random()-0.5)*1.1, 0, (Math.random()-0.5)*1.1);
                        addDirtySpot(child, s, 0.25 + Math.random()*0.4);
                    }
                }
            });

            camera.position.set(0, 3, 7);
        }

        function buildBuilding() {
            clearLevel();
            const building = new THREE.Group();
            
            // ä¸»æ¥¼ä½“ï¼ˆ10å±‚ï¼‰
            const mainBody = new THREE.Mesh(
                new THREE.BoxGeometry(6, 20, 4),
                new THREE.MeshPhongMaterial({ color: 0x888888 })
            );
            mainBody.position.y = 10;
            mainBody.castShadow = true;
            building.add(mainBody);
            
            // çª—æˆ·ï¼ˆæ¯å±‚4ä¸ªï¼‰
            for (let floor = 0; floor < 10; floor++) {
                for (let col = 0; col < 4; col++) {
                    const window = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.8, 1.2),
                        new THREE.MeshPhongMaterial({ color: 0x4488BB, transparent: true, opacity: 0.6 })
                    );
                    window.position.set(-2.5 + col * 1.5, 1.5 + floor * 2, 2.01);
                    building.add(window);
                    
                    // èƒŒé¢çª—æˆ·
                    const windowBack = window.clone();
                    windowBack.position.z = -2.01;
                    windowBack.rotation.y = Math.PI;
                    building.add(windowBack);
                }
            }
            
            // ä¾§é¢çª—æˆ·
            for (let floor = 0; floor < 10; floor++) {
                for (let side = -1; side <= 1; side += 2) {
                    for (let i = 0; i < 2; i++) {
                        const sideWindow = new THREE.Mesh(
                            new THREE.PlaneGeometry(0.8, 1.2),
                            new THREE.MeshPhongMaterial({ color: 0x4488BB, transparent: true, opacity: 0.6 })
                        );
                        sideWindow.position.set(side * 3.01, 1.5 + floor * 2, -1 + i * 2);
                        sideWindow.rotation.y = side > 0 ? -Math.PI/2 : Math.PI/2;
                        building.add(sideWindow);
                    }
                }
            }
            
            // é¡¶éƒ¨
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(6.2, 0.5, 4.2),
                new THREE.MeshPhongMaterial({ color: 0x555555 })
            );
            roof.position.y = 20.25;
            building.add(roof);
            
            // å¤§é—¨
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(2, 3, 0.2),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            door.position.set(0, 1.5, 2.1);
            building.add(door);
            
            // é—¨æŠŠæ‰‹
            const doorHandle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8),
                new THREE.MeshPhongMaterial({ color: 0xFFD700 })
            );
            doorHandle.rotation.x = Math.PI/2;
            doorHandle.position.set(0.6, 1.5, 2.2);
            building.add(doorHandle);
            
            // å°é˜¶
            for (let i = 0; i < 3; i++) {
                const step = new THREE.Mesh(
                    new THREE.BoxGeometry(3, 0.2, 0.8),
                    new THREE.MeshPhongMaterial({ color: 0x666666 })
                );
                step.position.set(0, 0.1 + i * 0.2, 2.5 + i * 0.3);
                building.add(step);
            }
            
            // æ‹›ç‰Œ
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(4, 1, 0.2),
                new THREE.MeshPhongMaterial({ color: 0x0066CC, emissive: 0x003366 })
            );
            sign.position.set(0, 4, 2.15);
            building.add(sign);
            
            // ç©ºè°ƒå¤–æœºï¼ˆæ¯å±‚2ä¸ªï¼‰
            for (let floor = 1; floor < 10; floor++) {
                for (let side = -1; side <= 1; side += 2) {
                    const ac = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.4, 0.3),
                        new THREE.MeshPhongMaterial({ color: 0xAAAAAA })
                    );
                    ac.position.set(side * 2.5, 1 + floor * 2, 2.2);
                    building.add(ac);
                }
            }

            scene.add(building);
            targetObjects.push(building);

            // è„æ±¡
            [mainBody, roof, door, sign].forEach(part => {
                const count = part === mainBody ? 120 : part === roof ? 60 : 50;
                for (let i = 0; i < count; i++) {
                    const box = new THREE.Box3().setFromObject(part);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    const s = new THREE.Vector3(
                        (Math.random()-0.5) * size.x * 0.95,
                        (Math.random()-0.5) * size.y * 0.95,
                        (Math.random()-0.5) * size.z * 0.95
                    );
                    addDirtySpot(part, s, 0.35 + Math.random()*0.6);
                }
            });
            
            // çª—æˆ·è„æ±¡
            building.children.forEach(child => {
                if (child.geometry && child.geometry.type === 'PlaneGeometry') {
                    for (let i = 0; i < 15; i++) {
                        const s = new THREE.Vector3((Math.random()-0.5)*0.7, (Math.random()-0.5)*1.1, 0.01);
                        addDirtySpot(child, s, 0.25 + Math.random()*0.4);
                    }
                }
            });

            camera.position.set(0, 12, 20);
        }

        function buildMixue() {
            clearLevel();
            const mixue = new THREE.Group();
            
            // åœ°æ¿
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 8),
                new THREE.MeshPhongMaterial({ color: 0xEEEEEE })
            );
            floor.rotation.x = -Math.PI/2;
            floor.position.y = 0.01;
            mixue.add(floor);
            
            // åº—é¢å¢™å£ï¼ˆçº¢è‰²ä¸»é¢˜ï¼‰
            const wall = new THREE.Mesh(
                new THREE.BoxGeometry(8, 4, 0.2),
                new THREE.MeshPhongMaterial({ color: 0xDD0000 })
            );
            wall.position.set(0, 2, -3.5);
            wall.castShadow = true;
            mixue.add(wall);
            
            // æ‹›ç‰Œï¼ˆçº¢è‰²èƒŒæ™¯ï¼‰
            const signBoard = new THREE.Mesh(
                new THREE.BoxGeometry(6, 1.5, 0.3),
                new THREE.MeshPhongMaterial({ color: 0xFF0000, emissive: 0x880000 })
            );
            signBoard.position.set(0, 4.5, -3.4);
            mixue.add(signBoard);
            
            // æ‹›ç‰Œæ–‡å­—åŒºåŸŸï¼ˆç™½è‰²ï¼‰
            const signText = new THREE.Mesh(
                new THREE.PlaneGeometry(5.5, 1.2),
                new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
            );
            signText.position.set(0, 4.5, -3.25);
            mixue.add(signText);
            
            // é›ªç‹logoä½ç½®ï¼ˆåœ†å½¢ç™½è‰²ï¼‰
            const logoCircle = new THREE.Mesh(
                new THREE.CircleGeometry(0.5, 32),
                new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
            );
            logoCircle.position.set(-2, 4.5, -3.2);
            mixue.add(logoCircle);
            
            // é›ªç‹ç®€åŒ–å½¢è±¡ï¼ˆé›ªäººï¼‰
            const snowmanBody = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16),
                new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
            );
            snowmanBody.position.set(-2, 4.5, -3.15);
            mixue.add(snowmanBody);
            
            const snowmanHead = new THREE.Mesh(
                new THREE.SphereGeometry(0.2, 16, 16),
                new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
            );
            snowmanHead.position.set(-2, 4.8, -3.15);
            mixue.add(snowmanHead);
            
            // é›ªç‹å¸½å­ï¼ˆçº¢è‰²ï¼‰
            const hat = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.2, 16),
                new THREE.MeshPhongMaterial({ color: 0xFF0000 })
            );
            hat.position.set(-2, 5, -3.15);
            mixue.add(hat);
            
            // æŸœå°
            const counter = new THREE.Mesh(
                new THREE.BoxGeometry(6, 1.2, 1.2),
                new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
            );
            counter.position.set(0, 0.6, -2.5);
            counter.castShadow = true;
            mixue.add(counter);
            
            // æŸœå°å°é¢ï¼ˆçº¢è‰²è£…é¥°ï¼‰
            const counterTop = new THREE.Mesh(
                new THREE.BoxGeometry(6.2, 0.1, 1.3),
                new THREE.MeshPhongMaterial({ color: 0xFF0000 })
            );
            counterTop.position.set(0, 1.25, -2.5);
            mixue.add(counterTop);
            
            // å†°æ·‡æ·‹æœº
            const iceCreamMachine = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.5, 0.8),
                new THREE.MeshPhongMaterial({ color: 0xCCCCCC })
            );
            iceCreamMachine.position.set(-2, 1.5, -2.5);
            mixue.add(iceCreamMachine);
            
            // é¥®æ–™æœº
            const drinkMachine = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1.8, 0.6),
                new THREE.MeshPhongMaterial({ color: 0x333333 })
            );
            drinkMachine.position.set(2, 1.2, -2.5);
            mixue.add(drinkMachine);
            
            // é¤æ¡Œï¼ˆçº¢ç™½é…è‰²ï¼‰
            for (let i = 0; i < 3; i++) {
                const table = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 0.05, 16),
                    new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
                );
                table.position.set(-2 + i * 2, 0.75, 1);
                table.castShadow = true;
                mixue.add(table);
                
                const tableLeg = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.1, 0.75, 8),
                    new THREE.MeshPhongMaterial({ color: 0xFF0000 })
                );
                tableLeg.position.set(-2 + i * 2, 0.375, 1);
                mixue.add(tableLeg);
                
                // æ¤…å­ï¼ˆçº¢è‰²ï¼‰
                for (let side = -1; side <= 1; side += 2) {
                    const chair = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 0.05, 0.4),
                        new THREE.MeshPhongMaterial({ color: 0xFF0000 })
                    );
                    chair.position.set(-2 + i * 2, 0.45, 1 + side * 0.8);
                    mixue.add(chair);
                }
            }
            
            // æ¯å­ï¼ˆåœ¨æŸœå°ä¸Šï¼‰
            for (let i = 0; i < 4; i++) {
                const cup = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.08, 0.25, 16),
                    new THREE.MeshPhongMaterial({ color: 0xFFFFFF })
                );
                cup.position.set(-1.5 + i * 0.5, 1.4, -2.5);
                mixue.add(cup);
            }
            
            // åƒåœ¾æ¡¶
            const trash = new THREE.Mesh(
                new THREE.CylinderGeometry(0.3, 0.35, 0.8, 8),
                new THREE.MeshPhongMaterial({ color: 0xFF0000 })
            );
            trash.position.set(3.5, 0.4, 2);
            mixue.add(trash);

            scene.add(mixue);
            targetObjects.push(mixue);

            // è„æ±¡
            const dirtyParts = [wall, signBoard, signText, counter, counterTop, iceCreamMachine, drinkMachine, floor];
            dirtyParts.forEach(part => {
                const count = part === floor ? 80 : part === wall ? 60 : 50;
                for (let i = 0; i < count; i++) {
                    const box = new THREE.Box3().setFromObject(part);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    const s = new THREE.Vector3(
                        (Math.random()-0.5) * size.x * 0.9,
                        (Math.random()-0.5) * size.y * 0.9,
                        (Math.random()-0.5) * size.z * 0.9
                    );
                    addDirtySpot(part, s, 0.3 + Math.random()*0.5);
                }
            });
            
            // é¤æ¡Œè„æ±¡
            mixue.children.forEach(child => {
                if (child.geometry && child.geometry.type === 'CylinderGeometry' && child.position.y > 0.7) {
                    for (let i = 0; i < 30; i++) {
                        const s = new THREE.Vector3((Math.random()-0.5)*0.9, 0, (Math.random()-0.5)*0.9);
                        addDirtySpot(child, s, 0.25 + Math.random()*0.4);
                    }
                }
            });

            camera.position.set(0, 3, 7);
        }

        // ========== æ¸¸æˆçŠ¶æ€ ==========
        let isPlaying = false, isSpraying = false;
        let waterPressure = 100;
        let viewMode = 0; // 0=ç¬¬ä¸€äººç§°, 1=ç¬¬ä¸‰äººç§°, 2=è‡ªç”±è§†è§’
        let orbitRadius = 10, orbitTheta = 0, orbitPhi = Math.PI/4;
        let camYaw = 0, camPitch = 0;
        let gunType = 0; // 0=æ ‡å‡†, 1=æ•£å°„, 2=é«˜å‹, 3=ç«ç®­ç­’, 4=åŸå­å¼¹
        const gunTypes = [
            { name: 'æ ‡å‡†æ°´æª', consume: 0.15, range: 1, particles: 3, damage: 1, color: 0x44BBFF, rocket: false, nuke: false },
            { name: 'æ•£å°„æ°´æª', consume: 0.25, range: 2, particles: 8, damage: 0.7, color: 0x66DDFF, rocket: false, nuke: false },
            { name: 'é«˜å‹æ°´æª', consume: 0.3, range: 0.5, particles: 1, damage: 2, color: 0x0088FF, rocket: false, nuke: false },
            { name: 'ç«ç®­ç­’æ°´ç‚®', consume: 1, range: 3, particles: 20, damage: 5, color: 0xFF6600, rocket: true, nuke: false },
            { name: 'åŸå­å¼¹æ°´ç‚®', consume: 10, range: 15, particles: 100, damage: 999, color: 0xFFFF00, rocket: true, nuke: true }
        ];
        const keys = {};

        function startLevel(type) {
            document.getElementById('levelSelect').style.display = 'none';
            if (type === 'car') buildCar();
            else if (type === 'house') buildHouse();
            else if (type === 'playground') buildPlayground();
            else if (type === 'robot') buildRobot();
            else if (type === 'kitchen') buildKitchen();
            else if (type === 'classroom') buildClassroom();
            else if (type === 'kfc') buildKFC();
            else if (type === 'building') buildBuilding();
            else if (type === 'mixue') buildMixue();
            isPlaying = true;
            viewMode = 0;
            gunType = 0;
            waterPressure = 100;
            camBasePos.set(0, 3, 8);
            camYaw = 0;
            camPitch = 0;
            orbitRadius = 10;
            orbitTheta = 0;
            orbitPhi = Math.PI/4;
            document.getElementById('viewToggle').textContent = 'ğŸ“· ç¬¬ä¸€äººç§° (V)';
            document.getElementById('gunType').textContent = gunTypes[0].name;
            renderer.domElement.requestPointerLock();
        }

        // é¼ æ ‡æ§åˆ¶
        const camBasePos = new THREE.Vector3(0, 3, 8);
        const sceneCenter = new THREE.Vector3(0, 2, 0);
        
        document.addEventListener('mousemove', e => {
            if (!isPlaying) return;
            if (document.pointerLockElement) {
                if (viewMode === 2) {
                    // è‡ªç”±è§†è§’ï¼šè½¨é“æ—‹è½¬
                    orbitTheta -= e.movementX * 0.005;
                    orbitPhi -= e.movementY * 0.005;
                    orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi));
                } else {
                    // ç¬¬ä¸€/ä¸‰äººç§°ï¼šæ­£å¸¸æ—‹è½¬
                    camYaw -= e.movementX * 0.003;
                    camPitch -= e.movementY * 0.003;
                    camPitch = Math.max(-1.2, Math.min(1.2, camPitch));
                }
            }
        });

        document.addEventListener('mousedown', () => { isSpraying = true; });
        document.addEventListener('mouseup', () => { isSpraying = false; });
        
        // é¼ æ ‡æ»šè½®ç¼©æ”¾
        document.addEventListener('wheel', e => {
            if (isPlaying && viewMode === 2) {
                e.preventDefault();
                orbitRadius += e.deltaY * 0.01;
                orbitRadius = Math.max(3, Math.min(50, orbitRadius));
            }
        }, { passive: false });
        
        renderer.domElement.addEventListener('click', () => {
            if (isPlaying && !document.pointerLockElement) renderer.domElement.requestPointerLock();
        });

        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            // è‡ªç”±è§†è§’ç¼©æ”¾
            if (viewMode === 2) {
                if (e.key === '=' || e.key === '+') orbitRadius = Math.max(3, orbitRadius - 1);
                if (e.key === '-' || e.key === '_') orbitRadius = Math.min(50, orbitRadius + 1);
            }
        });
        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            if (e.key.toLowerCase() === 'v' && isPlaying) {
                viewMode = (viewMode + 1) % 3;
                const modes = ['ğŸ“· ç¬¬ä¸€äººç§° (V)', 'ğŸ“· ç¬¬ä¸‰äººç§° (V)', 'ğŸ“· è‡ªç”±è§†è§’ (V)'];
                document.getElementById('viewToggle').textContent = modes[viewMode];
            }
            if (e.key.toLowerCase() === 'g' && isPlaying) {
                gunType = (gunType + 1) % gunTypes.length;
                document.getElementById('gunType').textContent = gunTypes[gunType].name;
                waterBeamMat.color.setHex(gunTypes[gunType].color);
            }
        });

        document.getElementById('viewToggle').addEventListener('click', () => {
            if (isPlaying) {
                viewMode = (viewMode + 1) % 3;
                const modes = ['ğŸ“· ç¬¬ä¸€äººç§° (V)', 'ğŸ“· ç¬¬ä¸‰äººç§° (V)', 'ğŸ“· è‡ªç”±è§†è§’ (V)'];
                document.getElementById('viewToggle').textContent = modes[viewMode];
            }
        });

        function switchGun() {
            if (!isPlaying) return;
            gunType = (gunType + 1) % gunTypes.length;
            document.getElementById('gunType').textContent = gunTypes[gunType].name;
            waterBeamMat.color.setHex(gunTypes[gunType].color);
        }

        function switchView() {
            if (!isPlaying) return;
            viewMode = (viewMode + 1) % 3;
            const modes = ['ğŸ“· ç¬¬ä¸€äººç§° (V)', 'ğŸ“· ç¬¬ä¸‰äººç§° (V)', 'ğŸ“· è‡ªç”±è§†è§’ (V)'];
            document.getElementById('viewToggle').textContent = modes[viewMode];
        }

        // ========== åŠ¨ç”» ==========
        let waterSoundTimer = 0;

        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying) {
                // WASDç§»åŠ¨
                const moveSpeed = 0.08;
                if (viewMode === 2) {
                    // è‡ªç”±è§†è§’ï¼šç§»åŠ¨è§‚å¯Ÿä¸­å¿ƒç‚¹
                    const forward = new THREE.Vector3(
                        Math.sin(orbitTheta) * Math.sin(orbitPhi),
                        -Math.cos(orbitPhi),
                        Math.cos(orbitTheta) * Math.sin(orbitPhi)
                    ).normalize();
                    const right = new THREE.Vector3(-Math.cos(orbitTheta), 0, Math.sin(orbitTheta)).normalize();
                    
                    if (keys['w']) sceneCenter.add(forward.clone().multiplyScalar(moveSpeed * 2));
                    if (keys['s']) sceneCenter.add(forward.clone().multiplyScalar(-moveSpeed * 2));
                    if (keys['a']) sceneCenter.add(right.clone().multiplyScalar(-moveSpeed * 2));
                    if (keys['d']) sceneCenter.add(right.clone().multiplyScalar(moveSpeed * 2));
                    if (keys['q']) sceneCenter.y += moveSpeed * 2;
                    if (keys['e']) sceneCenter.y -= moveSpeed * 2;
                } else {
                    // ç¬¬ä¸€/ä¸‰äººç§°ï¼šç§»åŠ¨è§’è‰²
                    const forward = new THREE.Vector3(-Math.sin(camYaw), 0, -Math.cos(camYaw));
                    const right = new THREE.Vector3(-Math.cos(camYaw), 0, Math.sin(camYaw));
                    if (keys['w']) camBasePos.add(forward.clone().multiplyScalar(moveSpeed));
                    if (keys['s']) camBasePos.add(forward.clone().multiplyScalar(-moveSpeed));
                    if (keys['a']) camBasePos.add(right.clone().multiplyScalar(-moveSpeed));
                    if (keys['d']) camBasePos.add(right.clone().multiplyScalar(moveSpeed));
                }

                // ç›¸æœºæœå‘
                const lookDir = new THREE.Vector3(
                    -Math.sin(camYaw) * Math.cos(camPitch),
                    Math.sin(camPitch),
                    -Math.cos(camYaw) * Math.cos(camPitch)
                );

                // è§†è§’åˆ‡æ¢
                if (viewMode === 0) {
                    // ç¬¬ä¸€äººç§°
                    camera.position.copy(camBasePos);
                    camera.lookAt(camBasePos.clone().add(lookDir));
                } else if (viewMode === 1) {
                    // ç¬¬ä¸‰äººç§°
                    const offset = lookDir.clone().multiplyScalar(-5).add(new THREE.Vector3(0, 2, 0));
                    camera.position.copy(camBasePos.clone().add(offset));
                    camera.lookAt(camBasePos);
                } else {
                    // è‡ªç”±è§†è§’ï¼ˆè½¨é“ç›¸æœºï¼‰
                    camera.position.set(
                        sceneCenter.x + orbitRadius * Math.sin(orbitPhi) * Math.cos(orbitTheta),
                        sceneCenter.y + orbitRadius * Math.cos(orbitPhi),
                        sceneCenter.z + orbitRadius * Math.sin(orbitPhi) * Math.sin(orbitTheta)
                    );
                    camera.lookAt(sceneCenter);
                }

                // å–·æ°´
                if (isSpraying && waterPressure > 0) {
                    const gun = gunTypes[gunType];
                    
                    if (gun.rocket) {
                        // ç«ç®­ç­’æ¨¡å¼ï¼šå‘å°„æ°´ç‚®å¼¹
                        if (waterPressure >= gun.consume) {
                            waterPressure -= gun.consume;
                            
                            const sprayOrigin = viewMode === 1 ? camBasePos.clone() : 
                                              viewMode === 2 ? camera.position.clone() : 
                                              camera.position.clone();
                            
                            const direction = new THREE.Vector3(0, 0, -1);
                            direction.applyQuaternion(camera.quaternion);
                            
                            const rocketSize = gun.nuke ? 0.4 : 0.2;
                            const rocket = new THREE.Mesh(
                                new THREE.SphereGeometry(rocketSize, 8, 8),
                                new THREE.MeshBasicMaterial({ color: gun.color, emissive: gun.color })
                            );
                            rocket.position.copy(sprayOrigin);
                            scene.add(rocket);
                            
                            rockets.push({
                                mesh: rocket,
                                velocity: direction.clone().multiplyScalar(gun.nuke ? 0.3 : 0.5),
                                life: gun.nuke ? 200 : 100,
                                isNuke: gun.nuke
                            });
                            
                            if (gun.nuke) playNuke();
                            else playRocket();
                            isSpraying = false; // å•å‘æ¨¡å¼
                        }
                    } else {
                        // æ™®é€šæ°´æªæ¨¡å¼
                        waterPressure = Math.max(0, waterPressure - gun.consume);

                        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                        const intersects = raycaster.intersectObjects(scene.children, true);

                        if (intersects.length > 0) {
                            const hit = intersects[0];

                            // æ°´æŸ±èµ·ç‚¹
                            const sprayOrigin = viewMode === 1 ? camBasePos.clone() : 
                                              viewMode === 2 ? camera.position.clone() : 
                                              camera.position.clone();

                            // æ°´æŸ±
                            waterBeam.visible = true;
                            const mid = sprayOrigin.clone().add(hit.point).multiplyScalar(0.5);
                            waterBeam.position.copy(mid);
                            waterBeam.scale.y = sprayOrigin.distanceTo(hit.point);
                            waterBeam.lookAt(hit.point);
                            waterBeam.rotateX(Math.PI/2);

                            // æ°´èŠ±ç²’å­
                            for (let i = 0; i < gun.particles; i++) {
                                const offset = gun.range > 1 ? 
                                    new THREE.Vector3((Math.random()-0.5)*gun.range, (Math.random()-0.5)*gun.range, (Math.random()-0.5)*gun.range) :
                                    new THREE.Vector3(0, 0, 0);
                                spawnWaterParticle(hit.point.clone().add(offset), hit.face ? hit.face.normal : new THREE.Vector3(0,1,0), gun.color);
                            }

                            // æ¸…æ´—è„æ±¡
                            dirtySpots.forEach(spot => {
                                if (spot.cleaned) return;
                                const spotWorld = new THREE.Vector3();
                                spot.mesh.getWorldPosition(spotWorld);
                                if (spotWorld.distanceTo(hit.point) < gun.range) {
                                    spot.hp -= gun.damage;
                                    spot.mesh.material.opacity = Math.max(0, spot.hp / 6) * 0.95;
                                    if (spot.hp <= 0) {
                                        spot.cleaned = true;
                                        spot.mesh.visible = false;
                                        cleanedSpots++;
                                        playClean();
                                    }
                                }
                            });

                            waterSoundTimer -= 0.016;
                            if (waterSoundTimer <= 0) { playWater(); waterSoundTimer = 0.1; }
                        }
                    }
                } else {
                    waterBeam.visible = false;
                }

                // æ°´å‹æ¢å¤
                if (!isSpraying) waterPressure = Math.min(100, waterPressure + 0.3);

                // æ›´æ–°ç²’å­
                for (let i = waterParticles.length-1; i >= 0; i--) {
                    const p = waterParticles[i];
                    p.mesh.position.x += p.vx;
                    p.mesh.position.y += p.vy;
                    p.mesh.position.z += p.vz;
                    p.vy -= 0.003;
                    p.life -= 0.04;
                    p.mesh.material.opacity = p.life * 0.8;
                    if (p.life <= 0) { scene.remove(p.mesh); waterParticles.splice(i, 1); }
                }

                // æ›´æ–°ç«ç®­å¼¹
                for (let i = rockets.length-1; i >= 0; i--) {
                    const r = rockets[i];
                    
                    // è‡ªåŠ¨è·Ÿè¸ªæœ€è¿‘çš„è„æ±¡
                    let nearestSpot = null;
                    let minDist = Infinity;
                    dirtySpots.forEach(spot => {
                        if (spot.cleaned) return;
                        const spotWorld = new THREE.Vector3();
                        spot.mesh.getWorldPosition(spotWorld);
                        const dist = r.mesh.position.distanceTo(spotWorld);
                        if (dist < 10 && dist < minDist) {
                            minDist = dist;
                            nearestSpot = spotWorld;
                        }
                    });
                    
                    // è°ƒæ•´é£è¡Œæ–¹å‘è¿½è¸ªç›®æ ‡
                    if (nearestSpot) {
                        const toTarget = nearestSpot.clone().sub(r.mesh.position).normalize();
                        r.velocity.lerp(toTarget.multiplyScalar(r.isNuke ? 0.3 : 0.5), 0.1);
                    }
                    
                    r.mesh.position.add(r.velocity);
                    r.life--;
                    
                    // åŸå­å¼¹å‘å…‰æ•ˆæœ
                    if (r.isNuke) {
                        r.mesh.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.01) * 0.5;
                    }
                    
                    // æ£€æµ‹ç¢°æ’
                    raycaster.set(r.mesh.position, r.velocity.clone().normalize());
                    const hits = raycaster.intersectObjects(scene.children, true);
                    
                    if (hits.length > 0 && hits[0].distance < 0.3 || r.life <= 0) {
                        // çˆ†ç‚¸æ•ˆæœ
                        const explosionPos = r.mesh.position.clone();
                        const explosionRange = r.isNuke ? 15 : 3;
                        const explosionDamage = r.isNuke ? 999 : 5;
                        const particleCount = r.isNuke ? 100 : 30;
                        
                        if (r.isNuke) {
                            playNuke();
                            // é—ªå…‰æ•ˆæœ
                            scene.background = new THREE.Color(0xFFFFFF);
                            setTimeout(() => scene.background = new THREE.Color(0x88bbee), 200);
                            
                            // åˆ›å»ºè˜‘è‡äº‘
                            const cloudGroup = new THREE.Group();
                            
                            // è˜‘è‡äº‘æŸ±ï¼ˆåº•éƒ¨ï¼‰
                            const stem = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.5, 1.5, 5, 16),
                                new THREE.MeshBasicMaterial({ 
                                    color: 0xFF8800, 
                                    transparent: true, 
                                    opacity: 0.8 
                                })
                            );
                            stem.position.copy(explosionPos);
                            stem.position.y += 2.5;
                            cloudGroup.add(stem);
                            
                            // è˜‘è‡äº‘é¡¶ï¼ˆä¸Šéƒ¨ï¼‰
                            const cap = new THREE.Mesh(
                                new THREE.SphereGeometry(2.5, 16, 16),
                                new THREE.MeshBasicMaterial({ 
                                    color: 0xFFAA00, 
                                    transparent: true, 
                                    opacity: 0.9 
                                })
                            );
                            cap.position.copy(explosionPos);
                            cap.position.y += 6;
                            cap.scale.y = 0.6;
                            cloudGroup.add(cap);
                            
                            // è˜‘è‡äº‘ç¯ï¼ˆä¸­éƒ¨ï¼‰
                            const ring = new THREE.Mesh(
                                new THREE.TorusGeometry(2, 0.8, 8, 16),
                                new THREE.MeshBasicMaterial({ 
                                    color: 0xFF6600, 
                                    transparent: true, 
                                    opacity: 0.7 
                                })
                            );
                            ring.position.copy(explosionPos);
                            ring.position.y += 5;
                            ring.rotation.x = Math.PI / 2;
                            cloudGroup.add(ring);
                            
                            scene.add(cloudGroup);
                            mushroomClouds.push({
                                group: cloudGroup,
                                life: 1,
                                startY: explosionPos.y
                            });
                        } else {
                            playExplosion();
                        }
                        
                        // çˆ†ç‚¸ç²’å­
                        for (let j = 0; j < particleCount; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            const angle2 = Math.random() * Math.PI;
                            const normal = new THREE.Vector3(
                                Math.sin(angle2) * Math.cos(angle),
                                Math.sin(angle2) * Math.sin(angle),
                                Math.cos(angle2)
                            );
                            spawnWaterParticle(explosionPos, normal, r.isNuke ? 0xFFFF00 : 0xFF6600);
                        }
                        
                        // èŒƒå›´æ¸…æ´—
                        dirtySpots.forEach(spot => {
                            if (spot.cleaned) return;
                            const spotWorld = new THREE.Vector3();
                            spot.mesh.getWorldPosition(spotWorld);
                            if (spotWorld.distanceTo(explosionPos) < explosionRange) {
                                spot.hp -= explosionDamage;
                                spot.mesh.material.opacity = Math.max(0, spot.hp / 6) * 0.95;
                                if (spot.hp <= 0) {
                                    spot.cleaned = true;
                                    spot.mesh.visible = false;
                                    cleanedSpots++;
                                    playClean();
                                }
                            }
                        });
                        
                        scene.remove(r.mesh);
                        rockets.splice(i, 1);
                    }
                }

                // æ›´æ–°è˜‘è‡äº‘
                for (let i = mushroomClouds.length-1; i >= 0; i--) {
                    const cloud = mushroomClouds[i];
                    cloud.life -= 0.01;
                    
                    // ä¸Šå‡å’Œæ‰©æ•£
                    cloud.group.position.y += 0.05;
                    cloud.group.scale.x += 0.02;
                    cloud.group.scale.z += 0.02;
                    cloud.group.scale.y += 0.01;
                    
                    // æ·¡å‡º
                    cloud.group.children.forEach(child => {
                        child.material.opacity = cloud.life * 0.8;
                    });
                    
                    // æ—‹è½¬
                    cloud.group.rotation.y += 0.02;
                    
                    if (cloud.life <= 0) {
                        scene.remove(cloud.group);
                        mushroomClouds.splice(i, 1);
                    }
                }

                // è¿›åº¦
                const pct = totalSpots > 0 ? Math.round(cleanedSpots / totalSpots * 100) : 0;
                document.getElementById('clean').textContent = pct;
                document.getElementById('progressFill').style.width = pct + '%';
                document.getElementById('progressText').textContent = 'æ¸…æ´è¿›åº¦ ' + pct + '%';
                document.getElementById('waterFill').style.width = waterPressure + '%';

                // è¯„ä»·
                const rating = pct >= 100 ? 'â­â­â­â­â­ å®Œç¾!' :
                               pct >= 80 ? 'â­â­â­â­' :
                               pct >= 60 ? 'â­â­â­' :
                               pct >= 30 ? 'â­â­' : 'â­';
                document.getElementById('rating').textContent = rating;

                // å®Œæˆ
                if (pct >= 100) {
                    const el = document.getElementById('splash');
                    if (el.style.opacity !== '1') {
                        el.textContent = 'âœ¨ å†²å®Œäº†! å®Œç¾æ¸…æ´! âœ¨';
                        el.style.opacity = 1;
                        playComplete();
                        setTimeout(() => {
                            el.style.opacity = 0;
                            document.getElementById('levelSelect').style.display = 'block';
                            document.exitPointerLock();
                            isPlaying = false;
                        }, 3000);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth/innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        animate();
    </script>
</body>
</html>
