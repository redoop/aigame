<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—‹è½¬é£æ¤…</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; font-family: Arial, sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 18px; z-index: 10;
        }
        #info {
            position: absolute; top: 20px; right: 20px;
            color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-align: right; font-size: 14px;
        }
        #controls {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 10;
        }
        button {
            padding: 12px 24px; font-size: 16px;
            background: rgba(255,255,255,0.9); border: 2px solid #333;
            border-radius: 8px; cursor: pointer; transition: all 0.3s;
        }
        button:hover { background: white; transform: scale(1.05); }
        button:active { transform: scale(0.95); }
    </style>
</head>
<body>
    <div id="ui">
        <div>é€Ÿåº¦: <span id="speed">0</span></div>
        <div>é«˜åº¦: <span id="height">0</span>m</div>
    </div>
    <div id="info">
        <div>ğŸ¡ æ—‹è½¬é£æ¤…</div>
        <div>é¼ æ ‡æ‹–åŠ¨æ—‹è½¬è§†è§’</div>
        <div>æ»šè½®ç¼©æ”¾</div>
    </div>
    <div id="controls">
        <button id="startBtn">å¯åŠ¨</button>
        <button id="speedUpBtn">åŠ é€Ÿ</button>
        <button id="slowDownBtn">å‡é€Ÿ</button>
        <button id="musicBtn">ğŸ”‡ éŸ³ä¹</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ========== éŸ³ä¹ç³»ç»Ÿ ==========
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let musicSource = null, isMusicPlaying = false;

        function createMusic() {
            if (musicSource) musicSource.stop();
            const dur = 8, sr = audioCtx.sampleRate;
            const buf = audioCtx.createBuffer(2, dur * sr, sr);
            // æ¬¢å¿«çš„æ¸¸ä¹åœºæ—‹å¾‹
            const melody = [
                392, 392, 440, 392, 523, 494,  // G G A G C B
                392, 392, 440, 392, 587, 523,  // G G A G D C
                392, 392, 784, 659, 523, 494, 440, // G G G5 E C B A
                698, 698, 659, 523, 587, 523   // F F E C D C
            ];
            const noteDur = dur / melody.length;

            for (let ch = 0; ch < 2; ch++) {
                const d = buf.getChannelData(ch);
                for (let i = 0; i < d.length; i++) {
                    const t = i / sr;
                    const noteIdx = Math.floor(t / noteDur) % melody.length;
                    const freq = melody[noteIdx];
                    const noteT = t % noteDur;
                    // ä¸»æ—‹å¾‹ + å’Œå£°
                    const envelope = Math.exp(-noteT * 3) * 0.8 + 0.2;
                    const main = Math.sin(2 * Math.PI * freq * t) * 0.12;
                    const harmony = Math.sin(2 * Math.PI * freq * 0.5 * t) * 0.04;
                    const chime = Math.sin(2 * Math.PI * freq * 2 * t) * 0.02 * Math.exp(-noteT * 8);
                    d[i] = (main + harmony + chime) * envelope;
                }
            }
            musicSource = audioCtx.createBufferSource();
            musicSource.buffer = buf;
            musicSource.loop = true;
            musicSource.connect(audioCtx.destination);
            return musicSource;
        }

        function toggleMusic() {
            if (isMusicPlaying) {
                if (musicSource) musicSource.stop();
                document.getElementById('musicBtn').textContent = 'ğŸ”‡ éŸ³ä¹';
            } else {
                createMusic().start(0);
                document.getElementById('musicBtn').textContent = 'ğŸ”Š éŸ³ä¹';
            }
            isMusicPlaying = !isMusicPlaying;
        }

        // ========== åœºæ™¯ ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 50, 200);

        const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
        camera.position.set(25, 15, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // å…‰ç…§
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(20, 40, 20);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // åœ°é¢
        const ground = new THREE.Mesh(
            new THREE.CircleGeometry(100, 64),
            new THREE.MeshLambertMaterial({ color: 0x90EE90 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // ========== æ—‹è½¬é£æ¤…ç»“æ„ ==========
        const POLE_HEIGHT = 18;
        const DISK_Y = POLE_HEIGHT;       // åœ†ç›˜ä¸­å¿ƒé«˜åº¦
        const DISK_RADIUS = 6;            // åœ†ç›˜åŠå¾„
        const CHAIN_LENGTH = 6;           // é“¾æ¡é•¿åº¦
        const NUM_CHAIRS = 12;

        // ä¸­å¿ƒæŸ±ï¼ˆå›ºå®šä¸åŠ¨ï¼‰
        const pole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.6, 0.8, POLE_HEIGHT, 32),
            new THREE.MeshPhongMaterial({ color: 0xFF6347 })
        );
        pole.position.y = POLE_HEIGHT / 2;
        pole.castShadow = true;
        scene.add(pole);

        // æ—‹è½¬ç»„ï¼ˆåœ†ç›˜ + æ‰€æœ‰é“¾æ¡æ¤…å­ï¼‰
        const rotatingGroup = new THREE.Group();
        rotatingGroup.position.y = DISK_Y;
        scene.add(rotatingGroup);

        // åœ†ç›˜
        const disk = new THREE.Mesh(
            new THREE.CylinderGeometry(DISK_RADIUS, DISK_RADIUS - 1, 1.5, 32),
            new THREE.MeshPhongMaterial({ color: 0xFFD700 })
        );
        disk.castShadow = true;
        rotatingGroup.add(disk);

        // åœ†ç›˜è¾¹ç¼˜çº¢è‰²æ ‡è®°
        const marker = new THREE.Mesh(
            new THREE.SphereGeometry(0.25, 16, 16),
            new THREE.MeshPhongMaterial({ color: 0xFF0000, emissive: 0xFF0000, emissiveIntensity: 0.5 })
        );
        marker.position.set(DISK_RADIUS - 0.5, -0.75, 0);
        rotatingGroup.add(marker);

        // åˆ›å»ºäººç‰©
        function createPerson() {
            const p = new THREE.Group();
            const skin = new THREE.MeshPhongMaterial({ color: 0xFFDBAC });
            const cloth = new THREE.MeshPhongMaterial({ color: 0x4169E1 });

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 12), skin);
            head.position.y = 1.6;
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.8, 12), cloth);
            body.position.y = 1.0;
            const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.6, 8), cloth);
            legL.position.set(-0.08, 0.3, 0);
            const legR = legL.clone(); legR.position.x = 0.08;

            p.add(head, body, legL, legR);
            return p;
        }

        // ========== å…³é”®ï¼šé“¾æ¡+æ¤…å­çš„æ­£ç¡®ç‰©ç†ç»“æ„ ==========
        //
        // ç»“æ„å±‚çº§ï¼š
        //   rotatingGroup (ä½äºåœ†ç›˜ä¸­å¿ƒï¼Œç»•Yè½´æ—‹è½¬)
        //     â””â”€ pivotGroup (ä½äºåœ†ç›˜è¾¹ç¼˜ï¼Œæ˜¯é“¾æ¡çš„æ‚¬æŒ‚ç‚¹)
        //          â””â”€ swingGroup (ç»•Xè½´æ—‹è½¬ï¼Œæ¨¡æ‹Ÿé“¾æ¡æ‘†åŠ¨)
        //               â”œâ”€ chain (é“¾æ¡)
        //               â””â”€ seat + person (åº§æ¤…å’Œäºº)
        //
        // ç‰©ç†åŸç†ï¼š
        //   - pivotGroup ä½äºåœ†ç›˜è¾¹ç¼˜ï¼Œè·Ÿéšåœ†ç›˜æ—‹è½¬
        //   - swingGroup çš„æ—‹è½¬åŸç‚¹åœ¨ pivotGroup ä½ç½®ï¼ˆå³é“¾æ¡é¡¶ç«¯ï¼‰
        //   - swingGroup ç»• X è½´æ—‹è½¬ = é“¾æ¡æ²¿å¾„å‘å‘å¤–å€¾æ–œ
        //   - ç¦»å¿ƒåŠ›è§’åº¦ Î¸ = atan(Ï‰Â²r / g)

        const chairs = [];

        for (let i = 0; i < NUM_CHAIRS; i++) {
            const angle = (i / NUM_CHAIRS) * Math.PI * 2;

            // æ‚¬æŒ‚ç‚¹ï¼šä½äºåœ†ç›˜è¾¹ç¼˜åº•éƒ¨
            const pivotGroup = new THREE.Group();
            pivotGroup.position.set(
                Math.cos(angle) * (DISK_RADIUS - 0.5),
                -0.75,  // åœ†ç›˜åº•éƒ¨
                Math.sin(angle) * (DISK_RADIUS - 0.5)
            );
            // è®© pivotGroup çš„ Z è½´æŒ‡å‘åœ†å¿ƒå¤–ä¾§
            // è¿™æ · swingGroup ç»• X è½´æ—‹è½¬å°±æ˜¯æ²¿å¾„å‘å€¾æ–œ
            pivotGroup.lookAt(
                Math.cos(angle) * (DISK_RADIUS + 10),
                -0.75,
                Math.sin(angle) * (DISK_RADIUS + 10)
            );

            // æ‘†åŠ¨ç»„ï¼šç»• X è½´æ—‹è½¬æ¨¡æ‹Ÿç¦»å¿ƒåŠ›å€¾æ–œ
            const swingGroup = new THREE.Group();

            // é“¾æ¡ï¼ˆä»æ‚¬æŒ‚ç‚¹å‘ä¸‹ï¼‰
            const chain = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.04, CHAIN_LENGTH, 8),
                new THREE.MeshPhongMaterial({ color: 0x888888 })
            );
            chain.position.y = -CHAIN_LENGTH / 2;
            swingGroup.add(chain);

            // åº§æ¤…
            const seatGroup = new THREE.Group();
            const seatColors = [0xFF1493, 0x00BFFF, 0x32CD32, 0xFF8C00, 0x9370DB, 0xFF6347];
            const seatMat = new THREE.MeshPhongMaterial({ color: seatColors[i % seatColors.length] });

            const seatBase = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 1.2), seatMat);
            const seatBack = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.5, 0.2), seatMat);
            seatBack.position.set(0, 0.75, -0.5);
            seatGroup.add(seatBase, seatBack);
            seatGroup.position.y = -CHAIN_LENGTH;

            // äººç‰©ååœ¨æ¤…å­ä¸Š
            const person = createPerson();
            person.position.y = 0.1;
            seatGroup.add(person);

            swingGroup.add(seatGroup);
            pivotGroup.add(swingGroup);
            rotatingGroup.add(pivotGroup);

            chairs.push({ pivotGroup, swingGroup, angle });
        }

        // ========== æ¸¸æˆçŠ¶æ€ ==========
        let rotSpeed = 0, isRunning = false;
        let currentSwingAngle = 0;  // å½“å‰æ‘†åŠ¨è§’åº¦ï¼ˆå¹³æ»‘è¿‡æ¸¡ï¼‰

        // ========== æ§åˆ¶ ==========
        document.getElementById('musicBtn').addEventListener('click', toggleMusic);

        document.getElementById('startBtn').addEventListener('click', () => {
            isRunning = !isRunning;
            document.getElementById('startBtn').textContent = isRunning ? 'åœæ­¢' : 'å¯åŠ¨';
            if (isRunning && rotSpeed === 0) rotSpeed = 0.01;
            if (isRunning && !isMusicPlaying) toggleMusic();
        });

        document.getElementById('speedUpBtn').addEventListener('click', () => {
            if (isRunning) rotSpeed = Math.min(rotSpeed + 0.005, 0.06);
        });

        document.getElementById('slowDownBtn').addEventListener('click', () => {
            rotSpeed = Math.max(rotSpeed - 0.005, 0);
        });

        // é¼ æ ‡æ§åˆ¶è§†è§’
        let isDragging = false, prevMouse = { x: 0, y: 0 };
        const lookTarget = new THREE.Vector3(0, DISK_Y - 2, 0);

        renderer.domElement.addEventListener('mousedown', e => {
            isDragging = true;
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        renderer.domElement.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const dx = e.clientX - prevMouse.x;
            const dy = e.clientY - prevMouse.y;
            
            // æ°´å¹³æ—‹è½¬
            camera.position.sub(lookTarget);
            camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -dx * 0.005);
            
            // å‚ç›´æ—‹è½¬ï¼ˆé™åˆ¶è§’åº¦ï¼‰
            const right = new THREE.Vector3().crossVectors(
                camera.position.clone().normalize(),
                new THREE.Vector3(0, 1, 0)
            ).normalize();
            const newPos = camera.position.clone().applyAxisAngle(right, -dy * 0.005);
            // é™åˆ¶ä¸èƒ½ç¿»è½¬åˆ°åœ°é¢ä»¥ä¸‹
            if (newPos.y > 1 && newPos.y < 80) {
                camera.position.copy(newPos);
            }
            
            camera.position.add(lookTarget);
            prevMouse = { x: e.clientX, y: e.clientY };
        });
        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        renderer.domElement.addEventListener('wheel', e => {
            e.preventDefault();
            const dir = camera.position.clone().sub(lookTarget).normalize();
            const dist = camera.position.distanceTo(lookTarget);
            const newDist = dist + e.deltaY * 0.05;
            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            if (newDist > 10 && newDist < 80) {
                camera.position.copy(lookTarget).add(dir.multiplyScalar(newDist));
            }
        });

        // ========== åŠ¨ç”» ==========
        function animate() {
            requestAnimationFrame(animate);

            // åœ†ç›˜æ—‹è½¬
            if (isRunning) {
                rotatingGroup.rotation.y += rotSpeed;
            }

            // ç¦»å¿ƒåŠ›è§’åº¦è®¡ç®—
            // Î¸ = atan(Ï‰Â²r / g)ï¼Œç®€åŒ–ä¸ºä¸é€Ÿåº¦å¹³æ–¹æˆæ­£æ¯”
            const targetSwingAngle = isRunning
                ? Math.min(rotSpeed * rotSpeed * 30000, Math.PI / 3)  // æœ€å¤§60åº¦
                : 0;

            // å¹³æ»‘è¿‡æ¸¡
            currentSwingAngle += (targetSwingAngle - currentSwingAngle) * 0.03;

            // åº”ç”¨åˆ°æ¯ä¸ªæ¤…å­
            chairs.forEach((chair, i) => {
                // æ¯ä¸ªæ¤…å­æœ‰è½»å¾®çš„æ‘†åŠ¨å·®å¼‚
                const swing = currentSwingAngle + Math.sin(Date.now() * 0.002 + i) * 0.02;
                // ç»• X è½´æ—‹è½¬ = æ²¿å¾„å‘å‘å¤–å€¾æ–œ
                chair.swingGroup.rotation.x = -swing;
            });

            // æ›´æ–°UI
            document.getElementById('speed').textContent = (rotSpeed * 1000).toFixed(1);
            document.getElementById('height').textContent = DISK_Y.toFixed(1);

            camera.lookAt(lookTarget);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        animate();
    </script>
</body>
</html>
